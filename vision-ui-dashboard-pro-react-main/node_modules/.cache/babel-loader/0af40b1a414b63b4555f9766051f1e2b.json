{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _slicedToArray = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _classCallCheck = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ListBinaryCodec = void 0;\n\nvar typesystem_1 = require(\"../typesystem\");\n\nvar constants_1 = require(\"./constants\");\n/**\n * Encodes and decodes \"List\" objects\n * with respect to: {@link https://docs.elrond.com/developers/developer-reference/elrond-serialization-format/ | The Elrond Serialization Format}.\n */\n\n\nvar ListBinaryCodec = /*#__PURE__*/function () {\n  function ListBinaryCodec(binaryCodec) {\n    _classCallCheck(this, ListBinaryCodec);\n\n    this.binaryCodec = binaryCodec;\n  }\n\n  _createClass(ListBinaryCodec, [{\n    key: \"decodeNested\",\n    value: function decodeNested(buffer, type) {\n      var typeParameter = type.getFirstTypeParameter();\n      var result = [];\n      var numItems = buffer.readUInt32BE(0);\n      this.binaryCodec.constraints.checkListLength(numItems);\n      var originalBuffer = buffer;\n      var offset = constants_1.SizeOfU32;\n      buffer = originalBuffer.slice(offset);\n\n      for (var i = 0; i < numItems; i++) {\n        var _this$binaryCodec$dec = this.binaryCodec.decodeNested(buffer, typeParameter),\n            _this$binaryCodec$dec2 = _slicedToArray(_this$binaryCodec$dec, 2),\n            decoded = _this$binaryCodec$dec2[0],\n            decodedLength = _this$binaryCodec$dec2[1];\n\n        result.push(decoded);\n        offset += decodedLength;\n        buffer = originalBuffer.slice(offset);\n      }\n\n      return [new typesystem_1.List(type, result), offset];\n    }\n  }, {\n    key: \"decodeTopLevel\",\n    value: function decodeTopLevel(buffer, type) {\n      var typeParameter = type.getFirstTypeParameter();\n      var result = [];\n      var originalBuffer = buffer;\n      var offset = 0;\n\n      while (buffer.length > 0) {\n        var _this$binaryCodec$dec3 = this.binaryCodec.decodeNested(buffer, typeParameter),\n            _this$binaryCodec$dec4 = _slicedToArray(_this$binaryCodec$dec3, 2),\n            decoded = _this$binaryCodec$dec4[0],\n            decodedLength = _this$binaryCodec$dec4[1];\n\n        result.push(decoded);\n        offset += decodedLength;\n        buffer = originalBuffer.slice(offset);\n        this.binaryCodec.constraints.checkListLength(result.length);\n      }\n\n      return new typesystem_1.List(type, result);\n    }\n  }, {\n    key: \"encodeNested\",\n    value: function encodeNested(list) {\n      this.binaryCodec.constraints.checkListLength(list.getLength());\n      var lengthBuffer = Buffer.alloc(constants_1.SizeOfU32);\n      lengthBuffer.writeUInt32BE(list.getLength());\n      var itemsBuffers = [];\n\n      var _iterator = _createForOfIteratorHelper(list.getItems()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n          var itemBuffer = this.binaryCodec.encodeNested(item);\n          itemsBuffers.push(itemBuffer);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var buffer = Buffer.concat([lengthBuffer].concat(itemsBuffers));\n      return buffer;\n    }\n  }, {\n    key: \"encodeTopLevel\",\n    value: function encodeTopLevel(list) {\n      this.binaryCodec.constraints.checkListLength(list.getLength());\n      var itemsBuffers = [];\n\n      var _iterator2 = _createForOfIteratorHelper(list.getItems()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var item = _step2.value;\n          var itemBuffer = this.binaryCodec.encodeNested(item);\n          itemsBuffers.push(itemBuffer);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var buffer = Buffer.concat(itemsBuffers);\n      return buffer;\n    }\n  }]);\n\n  return ListBinaryCodec;\n}();\n\nexports.ListBinaryCodec = ListBinaryCodec;","map":{"version":3,"sources":["../../../src/smartcontracts/codec/list.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ListBinaryCodec = void 0;\nconst typesystem_1 = require(\"../typesystem\");\nconst constants_1 = require(\"./constants\");\n/**\n * Encodes and decodes \"List\" objects\n * with respect to: {@link https://docs.elrond.com/developers/developer-reference/elrond-serialization-format/ | The Elrond Serialization Format}.\n */\nclass ListBinaryCodec {\n    constructor(binaryCodec) {\n        this.binaryCodec = binaryCodec;\n    }\n    decodeNested(buffer, type) {\n        let typeParameter = type.getFirstTypeParameter();\n        let result = [];\n        let numItems = buffer.readUInt32BE(0);\n        this.binaryCodec.constraints.checkListLength(numItems);\n        let originalBuffer = buffer;\n        let offset = constants_1.SizeOfU32;\n        buffer = originalBuffer.slice(offset);\n        for (let i = 0; i < numItems; i++) {\n            let [decoded, decodedLength] = this.binaryCodec.decodeNested(buffer, typeParameter);\n            result.push(decoded);\n            offset += decodedLength;\n            buffer = originalBuffer.slice(offset);\n        }\n        return [new typesystem_1.List(type, result), offset];\n    }\n    decodeTopLevel(buffer, type) {\n        let typeParameter = type.getFirstTypeParameter();\n        let result = [];\n        let originalBuffer = buffer;\n        let offset = 0;\n        while (buffer.length > 0) {\n            let [decoded, decodedLength] = this.binaryCodec.decodeNested(buffer, typeParameter);\n            result.push(decoded);\n            offset += decodedLength;\n            buffer = originalBuffer.slice(offset);\n            this.binaryCodec.constraints.checkListLength(result.length);\n        }\n        return new typesystem_1.List(type, result);\n    }\n    encodeNested(list) {\n        this.binaryCodec.constraints.checkListLength(list.getLength());\n        let lengthBuffer = Buffer.alloc(constants_1.SizeOfU32);\n        lengthBuffer.writeUInt32BE(list.getLength());\n        let itemsBuffers = [];\n        for (const item of list.getItems()) {\n            let itemBuffer = this.binaryCodec.encodeNested(item);\n            itemsBuffers.push(itemBuffer);\n        }\n        let buffer = Buffer.concat([lengthBuffer, ...itemsBuffers]);\n        return buffer;\n    }\n    encodeTopLevel(list) {\n        this.binaryCodec.constraints.checkListLength(list.getLength());\n        let itemsBuffers = [];\n        for (const item of list.getItems()) {\n            let itemBuffer = this.binaryCodec.encodeNested(item);\n            itemsBuffers.push(itemBuffer);\n        }\n        let buffer = Buffer.concat(itemsBuffers);\n        return buffer;\n    }\n}\nexports.ListBinaryCodec = ListBinaryCodec;\n//# sourceMappingURL=list.js.map"]},"metadata":{},"sourceType":"script"}