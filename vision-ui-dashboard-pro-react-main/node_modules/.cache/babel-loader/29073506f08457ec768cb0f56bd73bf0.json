{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _classCallCheck = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EnumBinaryCodec = void 0;\n\nvar typesystem_1 = require(\"../typesystem\");\n\nvar fields_1 = require(\"./fields\");\n\nvar EnumBinaryCodec = /*#__PURE__*/function () {\n  function EnumBinaryCodec(binaryCodec) {\n    _classCallCheck(this, EnumBinaryCodec);\n\n    this.binaryCodec = binaryCodec;\n    this.fieldsCodec = new fields_1.FieldsBinaryCodec(binaryCodec);\n  }\n\n  _createClass(EnumBinaryCodec, [{\n    key: \"decodeTopLevel\",\n    value: function decodeTopLevel(buffer, type) {\n      // This handles enums without fields, with discriminant = 0, as well.\n      var _this$decodeNested = this.decodeNested(buffer, type),\n          _this$decodeNested2 = _slicedToArray(_this$decodeNested, 1),\n          enumValue = _this$decodeNested2[0];\n\n      return enumValue;\n    }\n  }, {\n    key: \"decodeNested\",\n    value: function decodeNested(buffer, type) {\n      var _this$readDiscriminan = this.readDiscriminant(buffer),\n          _this$readDiscriminan2 = _slicedToArray(_this$readDiscriminan, 2),\n          discriminant = _this$readDiscriminan2[0],\n          lengthOfDiscriminant = _this$readDiscriminan2[1];\n\n      buffer = buffer.slice(lengthOfDiscriminant);\n      var variant = type.getVariantByDiscriminant(discriminant);\n      var fieldDefinitions = variant.getFieldsDefinitions();\n\n      var _this$fieldsCodec$dec = this.fieldsCodec.decodeNested(buffer, fieldDefinitions),\n          _this$fieldsCodec$dec2 = _slicedToArray(_this$fieldsCodec$dec, 2),\n          fields = _this$fieldsCodec$dec2[0],\n          lengthOfFields = _this$fieldsCodec$dec2[1];\n\n      var enumValue = new typesystem_1.EnumValue(type, variant, fields);\n      return [enumValue, lengthOfDiscriminant + lengthOfFields];\n    }\n  }, {\n    key: \"readDiscriminant\",\n    value: function readDiscriminant(buffer) {\n      var _this$binaryCodec$dec = this.binaryCodec.decodeNested(buffer, new typesystem_1.U8Type()),\n          _this$binaryCodec$dec2 = _slicedToArray(_this$binaryCodec$dec, 2),\n          value = _this$binaryCodec$dec2[0],\n          length = _this$binaryCodec$dec2[1];\n\n      var discriminant = value.valueOf();\n      return [discriminant, length];\n    }\n  }, {\n    key: \"encodeNested\",\n    value: function encodeNested(enumValue) {\n      var discriminant = new typesystem_1.U8Value(enumValue.discriminant);\n      var discriminantBuffer = this.binaryCodec.encodeNested(discriminant);\n      var fields = enumValue.getFields();\n      var fieldsBuffer = this.fieldsCodec.encodeNested(fields);\n      return Buffer.concat([discriminantBuffer, fieldsBuffer]);\n    }\n  }, {\n    key: \"encodeTopLevel\",\n    value: function encodeTopLevel(enumValue) {\n      var fields = enumValue.getFields();\n      var hasFields = fields.length > 0;\n      var fieldsBuffer = this.fieldsCodec.encodeNested(fields);\n      var discriminant = new typesystem_1.U8Value(enumValue.discriminant);\n      var discriminantBuffer = hasFields ? this.binaryCodec.encodeNested(discriminant) : this.binaryCodec.encodeTopLevel(discriminant);\n      return Buffer.concat([discriminantBuffer, fieldsBuffer]);\n    }\n  }]);\n\n  return EnumBinaryCodec;\n}();\n\nexports.EnumBinaryCodec = EnumBinaryCodec;","map":{"version":3,"sources":["../../../src/smartcontracts/codec/enum.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,IAAA,YAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AAEA,IAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;IAEa,e;EAIT,yBAAY,WAAZ,EAAoC;IAAA;;IAChC,KAAK,WAAL,GAAmB,WAAnB;IACA,KAAK,WAAL,GAAmB,IAAI,QAAA,CAAA,iBAAJ,CAAsB,WAAtB,CAAnB;EACH;;;;WAED,wBAAe,MAAf,EAA+B,IAA/B,EAA6C;MACzC;MACA,yBAAkB,KAAK,YAAL,CAAkB,MAAlB,EAA0B,IAA1B,CAAlB;MAAA;MAAA,IAAK,SAAL;;MACA,OAAO,SAAP;IACH;;;WAED,sBAAa,MAAb,EAA6B,IAA7B,EAA2C;MACvC,4BAA2C,KAAK,gBAAL,CAAsB,MAAtB,CAA3C;MAAA;MAAA,IAAK,YAAL;MAAA,IAAmB,oBAAnB;;MACA,MAAM,GAAG,MAAM,CAAC,KAAP,CAAa,oBAAb,CAAT;MAEA,IAAI,OAAO,GAAG,IAAI,CAAC,wBAAL,CAA8B,YAA9B,CAAd;MACA,IAAI,gBAAgB,GAAG,OAAO,CAAC,oBAAR,EAAvB;;MAEA,4BAAkD,KAAK,WAAL,CAAiB,YAAjB,CAA8B,MAA9B,EAAsC,gBAAtC,CAAlD;MAAA;MAAA,IAAK,MAAL;MAAA,IAAa,cAAb;;MACA,IAAI,SAAS,GAAG,IAAI,YAAA,CAAA,SAAJ,CAAc,IAAd,EAAoB,OAApB,EAA6B,MAA7B,CAAhB;MAEA,OAAO,CAAC,SAAD,EAAY,oBAAoB,GAAG,cAAnC,CAAP;IACH;;;WAEO,0BAAiB,MAAjB,EAA+B;MACnC,4BAAsB,KAAK,WAAL,CAAiB,YAAjB,CAA8B,MAA9B,EAAsC,IAAI,YAAA,CAAA,MAAJ,EAAtC,CAAtB;MAAA;MAAA,IAAK,KAAL;MAAA,IAAY,MAAZ;;MACA,IAAI,YAAY,GAAG,KAAK,CAAC,OAAN,EAAnB;MAEA,OAAO,CAAC,YAAD,EAAe,MAAf,CAAP;IACH;;;WAED,sBAAa,SAAb,EAAiC;MAC7B,IAAI,YAAY,GAAG,IAAI,YAAA,CAAA,OAAJ,CAAY,SAAS,CAAC,YAAtB,CAAnB;MACA,IAAI,kBAAkB,GAAG,KAAK,WAAL,CAAiB,YAAjB,CAA8B,YAA9B,CAAzB;MAEA,IAAI,MAAM,GAAG,SAAS,CAAC,SAAV,EAAb;MACA,IAAI,YAAY,GAAG,KAAK,WAAL,CAAiB,YAAjB,CAA8B,MAA9B,CAAnB;MAEA,OAAO,MAAM,CAAC,MAAP,CAAc,CAAC,kBAAD,EAAqB,YAArB,CAAd,CAAP;IACH;;;WAED,wBAAe,SAAf,EAAmC;MAC/B,IAAI,MAAM,GAAG,SAAS,CAAC,SAAV,EAAb;MACA,IAAI,SAAS,GAAG,MAAM,CAAC,MAAP,GAAgB,CAAhC;MACA,IAAI,YAAY,GAAG,KAAK,WAAL,CAAiB,YAAjB,CAA8B,MAA9B,CAAnB;MAEA,IAAI,YAAY,GAAG,IAAI,YAAA,CAAA,OAAJ,CAAY,SAAS,CAAC,YAAtB,CAAnB;MACA,IAAI,kBAAkB,GAAG,SAAS,GAAG,KAAK,WAAL,CAAiB,YAAjB,CAA8B,YAA9B,CAAH,GAAiD,KAAK,WAAL,CAAiB,cAAjB,CAAgC,YAAhC,CAAnF;MAEA,OAAO,MAAM,CAAC,MAAP,CAAc,CAAC,kBAAD,EAAqB,YAArB,CAAd,CAAP;IACH;;;;;;AAtDL,OAAA,CAAA,eAAA,GAAA,eAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EnumBinaryCodec = void 0;\nconst typesystem_1 = require(\"../typesystem\");\nconst fields_1 = require(\"./fields\");\nclass EnumBinaryCodec {\n    constructor(binaryCodec) {\n        this.binaryCodec = binaryCodec;\n        this.fieldsCodec = new fields_1.FieldsBinaryCodec(binaryCodec);\n    }\n    decodeTopLevel(buffer, type) {\n        // This handles enums without fields, with discriminant = 0, as well.\n        let [enumValue] = this.decodeNested(buffer, type);\n        return enumValue;\n    }\n    decodeNested(buffer, type) {\n        let [discriminant, lengthOfDiscriminant] = this.readDiscriminant(buffer);\n        buffer = buffer.slice(lengthOfDiscriminant);\n        let variant = type.getVariantByDiscriminant(discriminant);\n        let fieldDefinitions = variant.getFieldsDefinitions();\n        let [fields, lengthOfFields] = this.fieldsCodec.decodeNested(buffer, fieldDefinitions);\n        let enumValue = new typesystem_1.EnumValue(type, variant, fields);\n        return [enumValue, lengthOfDiscriminant + lengthOfFields];\n    }\n    readDiscriminant(buffer) {\n        let [value, length] = this.binaryCodec.decodeNested(buffer, new typesystem_1.U8Type());\n        let discriminant = value.valueOf();\n        return [discriminant, length];\n    }\n    encodeNested(enumValue) {\n        let discriminant = new typesystem_1.U8Value(enumValue.discriminant);\n        let discriminantBuffer = this.binaryCodec.encodeNested(discriminant);\n        let fields = enumValue.getFields();\n        let fieldsBuffer = this.fieldsCodec.encodeNested(fields);\n        return Buffer.concat([discriminantBuffer, fieldsBuffer]);\n    }\n    encodeTopLevel(enumValue) {\n        let fields = enumValue.getFields();\n        let hasFields = fields.length > 0;\n        let fieldsBuffer = this.fieldsCodec.encodeNested(fields);\n        let discriminant = new typesystem_1.U8Value(enumValue.discriminant);\n        let discriminantBuffer = hasFields ? this.binaryCodec.encodeNested(discriminant) : this.binaryCodec.encodeTopLevel(discriminant);\n        return Buffer.concat([discriminantBuffer, fieldsBuffer]);\n    }\n}\nexports.EnumBinaryCodec = EnumBinaryCodec;\n//# sourceMappingURL=enum.js.map"]},"metadata":{},"sourceType":"script"}