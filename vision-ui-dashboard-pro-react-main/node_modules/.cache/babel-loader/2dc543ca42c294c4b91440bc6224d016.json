{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Tuple = exports.TupleType = void 0;\n\nconst errors = __importStar(require(\"../../errors\"));\n\nconst struct_1 = require(\"./struct\");\n\nconst fields_1 = require(\"./fields\");\n\nconst struct_2 = require(\"./struct\");\n\nclass TupleType extends struct_2.StructType {\n  constructor() {\n    for (var _len = arguments.length, typeParameters = new Array(_len), _key = 0; _key < _len; _key++) {\n      typeParameters[_key] = arguments[_key];\n    }\n\n    super(TupleType.prepareName(typeParameters), TupleType.prepareFieldDefinitions(typeParameters));\n  }\n\n  static prepareName(typeParameters) {\n    let fields = typeParameters.map(type => type.toString()).join(\", \");\n    let result = `tuple${fields.length}<${fields}>`;\n    return result;\n  }\n\n  static prepareFieldDefinitions(typeParameters) {\n    let result = typeParameters.map((type, i) => new fields_1.FieldDefinition(prepareFieldName(i), \"anonymous tuple field\", type));\n    return result;\n  }\n\n}\n\nexports.TupleType = TupleType;\n\nfunction prepareFieldName(fieldIndex) {\n  return `field${fieldIndex}`;\n} // TODO: Perhaps add a common base class for Struct and Tuple, called FieldsHolder?\n// Or let Tuple be the base class, but have Struct as a specialization of it, \"named tuple\"?\n// Or leave as it is?\n\n\nclass Tuple extends struct_1.Struct {\n  constructor(type, fields) {\n    super(type, fields);\n  }\n\n  static fromItems(items) {\n    if (items.length < 1) {\n      // TODO: Define a better error.\n      throw new errors.ErrTypingSystem(\"bad tuple items\");\n    }\n\n    let fieldsTypes = items.map(item => item.getType());\n    let tupleType = new TupleType(...fieldsTypes);\n    let fields = items.map((item, i) => new fields_1.Field(item, prepareFieldName(i)));\n    return new Tuple(tupleType, fields);\n  }\n\n}\n\nexports.Tuple = Tuple;","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/tuple.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA,MAAA,GAAA,YAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAEA,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAEA,MAAa,SAAb,SAA+B,QAAA,CAAA,UAA/B,CAAyC;EACrC,WAAA,GAAqC;IAAA,kCAAtB,cAAsB;MAAtB,cAAsB;IAAA;;IACjC,MAAM,SAAS,CAAC,WAAV,CAAsB,cAAtB,CAAN,EAA6C,SAAS,CAAC,uBAAV,CAAkC,cAAlC,CAA7C;EACH;;EAEyB,OAAX,WAAW,CAAC,cAAD,EAAuB;IAC7C,IAAI,MAAM,GAAW,cAAc,CAAC,GAAf,CAAmB,IAAI,IAAI,IAAI,CAAC,QAAL,EAA3B,EAA4C,IAA5C,CAAiD,IAAjD,CAArB;IACA,IAAI,MAAM,GAAG,QAAQ,MAAM,CAAC,MAAM,IAAI,MAAM,GAA5C;IACA,OAAO,MAAP;EACH;;EAEqC,OAAvB,uBAAuB,CAAC,cAAD,EAAuB;IACzD,IAAI,MAAM,GAAG,cAAc,CAAC,GAAf,CAAmB,CAAC,IAAD,EAAO,CAAP,KAAa,IAAI,QAAA,CAAA,eAAJ,CAAoB,gBAAgB,CAAC,CAAD,CAApC,EAAyC,uBAAzC,EAAkE,IAAlE,CAAhC,CAAb;IACA,OAAO,MAAP;EACH;;AAdoC;;AAAzC,OAAA,CAAA,SAAA,GAAA,SAAA;;AAiBA,SAAS,gBAAT,CAA0B,UAA1B,EAA4C;EACxC,OAAO,QAAQ,UAAU,EAAzB;AACH,C,CAED;AACA;AACA;;;AACA,MAAa,KAAb,SAA2B,QAAA,CAAA,MAA3B,CAAiC;EAC7B,WAAA,CAAY,IAAZ,EAA6B,MAA7B,EAA4C;IACxC,MAAM,IAAN,EAAY,MAAZ;EACH;;EAEe,OAAT,SAAS,CAAC,KAAD,EAAoB;IAChC,IAAI,KAAK,CAAC,MAAN,GAAe,CAAnB,EAAsB;MAClB;MACA,MAAM,IAAI,MAAM,CAAC,eAAX,CAA2B,iBAA3B,CAAN;IACH;;IAED,IAAI,WAAW,GAAG,KAAK,CAAC,GAAN,CAAU,IAAI,IAAI,IAAI,CAAC,OAAL,EAAlB,CAAlB;IACA,IAAI,SAAS,GAAG,IAAI,SAAJ,CAAc,GAAG,WAAjB,CAAhB;IACA,IAAI,MAAM,GAAG,KAAK,CAAC,GAAN,CAAU,CAAC,IAAD,EAAO,CAAP,KAAa,IAAI,QAAA,CAAA,KAAJ,CAAU,IAAV,EAAgB,gBAAgB,CAAC,CAAD,CAAhC,CAAvB,CAAb;IAEA,OAAO,IAAI,KAAJ,CAAU,SAAV,EAAqB,MAArB,CAAP;EACH;;AAhB4B;;AAAjC,OAAA,CAAA,KAAA,GAAA,KAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Tuple = exports.TupleType = void 0;\nconst errors = __importStar(require(\"../../errors\"));\nconst struct_1 = require(\"./struct\");\nconst fields_1 = require(\"./fields\");\nconst struct_2 = require(\"./struct\");\nclass TupleType extends struct_2.StructType {\n    constructor(...typeParameters) {\n        super(TupleType.prepareName(typeParameters), TupleType.prepareFieldDefinitions(typeParameters));\n    }\n    static prepareName(typeParameters) {\n        let fields = typeParameters.map(type => type.toString()).join(\", \");\n        let result = `tuple${fields.length}<${fields}>`;\n        return result;\n    }\n    static prepareFieldDefinitions(typeParameters) {\n        let result = typeParameters.map((type, i) => new fields_1.FieldDefinition(prepareFieldName(i), \"anonymous tuple field\", type));\n        return result;\n    }\n}\nexports.TupleType = TupleType;\nfunction prepareFieldName(fieldIndex) {\n    return `field${fieldIndex}`;\n}\n// TODO: Perhaps add a common base class for Struct and Tuple, called FieldsHolder?\n// Or let Tuple be the base class, but have Struct as a specialization of it, \"named tuple\"?\n// Or leave as it is?\nclass Tuple extends struct_1.Struct {\n    constructor(type, fields) {\n        super(type, fields);\n    }\n    static fromItems(items) {\n        if (items.length < 1) {\n            // TODO: Define a better error.\n            throw new errors.ErrTypingSystem(\"bad tuple items\");\n        }\n        let fieldsTypes = items.map(item => item.getType());\n        let tupleType = new TupleType(...fieldsTypes);\n        let fields = items.map((item, i) => new fields_1.Field(item, prepareFieldName(i)));\n        return new Tuple(tupleType, fields);\n    }\n}\nexports.Tuple = Tuple;\n//# sourceMappingURL=tuple.js.map"]},"metadata":{},"sourceType":"script"}