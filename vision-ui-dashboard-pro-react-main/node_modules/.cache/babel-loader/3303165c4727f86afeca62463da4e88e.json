{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NullType = exports.TypePlaceholder = exports.isTyped = exports.PrimitiveValue = exports.TypedValue = exports.CustomType = exports.PrimitiveType = exports.TypeCardinality = exports.Type = void 0;\n\nconst utils_1 = require(\"../../utils\");\n/**\n * An abstraction that represents a Type. Handles both generic and non-generic types.\n * Once instantiated as a Type, a generic type is \"closed\" (as opposed to \"open\").\n */\n\n\nclass Type {\n  constructor(name) {\n    let typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let cardinality = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TypeCardinality.fixed(1);\n    utils_1.guardValueIsSet(\"name\", name);\n    this.name = name;\n    this.typeParameters = typeParameters;\n    this.cardinality = cardinality;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  getTypeParameters() {\n    return this.typeParameters;\n  }\n\n  isGenericType() {\n    return this.typeParameters.length > 0;\n  }\n\n  getFirstTypeParameter() {\n    utils_1.guardTrue(this.typeParameters.length > 0, \"type parameters length > 0\");\n    return this.typeParameters[0];\n  }\n  /**\n   * Generates type expressions similar to elrond-wasm-rs.\n   */\n\n\n  toString() {\n    let typeParameters = this.getTypeParameters().map(type => type.toString()).join(\", \");\n    let typeParametersExpression = typeParameters ? `<${typeParameters}>` : \"\";\n    return `${this.name}${typeParametersExpression}`;\n  }\n\n  equals(other) {\n    return Type.equals(this, other);\n  }\n\n  static equals(a, b) {\n    // Workaround that seems to always work properly. Most probable reasons: \n    // - ES6 is quite strict about enumerating over the properties on an object.\n    // - toJSON() returns an object literal (most probably, this results in deterministic iteration in all browser implementations).\n    let aJson = JSON.stringify(a.toJSON());\n    let bJson = JSON.stringify(b.toJSON());\n    return aJson == bJson;\n  }\n\n  static equalsMany(a, b) {\n    return a.every((type, i) => type.equals(b[i]));\n  }\n\n  static isAssignableFromMany(a, b) {\n    return a.every((type, i) => type.isAssignableFrom(b[i]));\n  }\n\n  differs(other) {\n    return !this.equals(other);\n  }\n\n  valueOf() {\n    return this.name;\n  }\n  /**\n   * Inspired from: https://docs.microsoft.com/en-us/dotnet/api/system.type.isassignablefrom\n   * For (most) generics, type invariance is expected (assumed) - neither covariance, nor contravariance are supported yet (will be supported in a next release).\n   *\n   * One exception though: for {@link OptionType}, we simulate covariance for missing (not provided) values.\n   * For example, Option<u32> is assignable from Option<?>.\n   * For more details, see the implementation of {@link OptionType}.\n   *\n   * Also see:\n   *  - https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)\n   *  - https://docs.microsoft.com/en-us/dotnet/standard/generics/covariance-and-contravariance\n   */\n\n\n  isAssignableFrom(type) {\n    let invariantTypeParameters = Type.equalsMany(this.getTypeParameters(), type.getTypeParameters());\n    return type instanceof this.constructor && invariantTypeParameters;\n  }\n  /**\n   * Converts the account to a pretty, plain JavaScript object.\n   */\n\n\n  toJSON() {\n    return {\n      name: this.name,\n      typeParameters: this.typeParameters.map(item => item.toJSON())\n    };\n  }\n\n  getCardinality() {\n    return this.cardinality;\n  }\n\n}\n\nexports.Type = Type;\n/**\n * TODO: Simplify this class, keep only what is needed.\n *\n * An abstraction for defining and operating with the cardinality of a (composite or simple) type.\n *\n * Simple types (the ones that are directly encodable) have a fixed cardinality: [lower = 1, upper = 1].\n * Composite types (not directly encodable) do not follow this constraint. For example:\n *  - VarArgs: [lower = 0, upper = *]\n *  - OptionalResult: [lower = 0, upper = 1]\n */\n\nclass TypeCardinality {\n  constructor(lowerBound, upperBound) {\n    this.lowerBound = lowerBound;\n    this.upperBound = upperBound;\n  }\n\n  static fixed(value) {\n    return new TypeCardinality(value, value);\n  }\n\n  static variable(value) {\n    return new TypeCardinality(0, value);\n  }\n\n  isSingular() {\n    return this.lowerBound == 1 && this.upperBound == 1;\n  }\n\n  isSingularOrNone() {\n    return this.lowerBound == 0 && this.upperBound == 1;\n  }\n\n  isComposite() {\n    return this.upperBound != 1;\n  }\n\n  isFixed() {\n    return this.lowerBound == this.upperBound;\n  }\n\n  getLowerBound() {\n    return this.lowerBound;\n  }\n\n  getUpperBound() {\n    return this.upperBound || TypeCardinality.MaxCardinality;\n  }\n\n}\n\nexports.TypeCardinality = TypeCardinality;\n/**\n * An arbitrarily chosen, reasonably large number.\n */\n\nTypeCardinality.MaxCardinality = 4096;\n\nclass PrimitiveType extends Type {\n  constructor(name) {\n    super(name);\n  }\n\n}\n\nexports.PrimitiveType = PrimitiveType;\n\nclass CustomType extends Type {}\n\nexports.CustomType = CustomType;\n\nclass TypedValue {\n  constructor(type) {\n    this.type = type;\n  }\n\n  getType() {\n    return this.type;\n  }\n\n}\n\nexports.TypedValue = TypedValue;\n\nclass PrimitiveValue extends TypedValue {\n  constructor(type) {\n    super(type);\n  }\n\n}\n\nexports.PrimitiveValue = PrimitiveValue;\n\nfunction isTyped(value) {\n  return value instanceof TypedValue;\n}\n\nexports.isTyped = isTyped;\n\nclass TypePlaceholder extends Type {\n  constructor() {\n    super(\"...\");\n  }\n\n}\n\nexports.TypePlaceholder = TypePlaceholder;\n\nclass NullType extends Type {\n  constructor() {\n    super(\"?\");\n  }\n\n}\n\nexports.NullType = NullType;","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/types.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NullType = exports.TypePlaceholder = exports.isTyped = exports.PrimitiveValue = exports.TypedValue = exports.CustomType = exports.PrimitiveType = exports.TypeCardinality = exports.Type = void 0;\nconst utils_1 = require(\"../../utils\");\n/**\n * An abstraction that represents a Type. Handles both generic and non-generic types.\n * Once instantiated as a Type, a generic type is \"closed\" (as opposed to \"open\").\n */\nclass Type {\n    constructor(name, typeParameters = [], cardinality = TypeCardinality.fixed(1)) {\n        utils_1.guardValueIsSet(\"name\", name);\n        this.name = name;\n        this.typeParameters = typeParameters;\n        this.cardinality = cardinality;\n    }\n    getName() {\n        return this.name;\n    }\n    getTypeParameters() {\n        return this.typeParameters;\n    }\n    isGenericType() {\n        return this.typeParameters.length > 0;\n    }\n    getFirstTypeParameter() {\n        utils_1.guardTrue(this.typeParameters.length > 0, \"type parameters length > 0\");\n        return this.typeParameters[0];\n    }\n    /**\n     * Generates type expressions similar to elrond-wasm-rs.\n     */\n    toString() {\n        let typeParameters = this.getTypeParameters().map(type => type.toString()).join(\", \");\n        let typeParametersExpression = typeParameters ? `<${typeParameters}>` : \"\";\n        return `${this.name}${typeParametersExpression}`;\n    }\n    equals(other) {\n        return Type.equals(this, other);\n    }\n    static equals(a, b) {\n        // Workaround that seems to always work properly. Most probable reasons: \n        // - ES6 is quite strict about enumerating over the properties on an object.\n        // - toJSON() returns an object literal (most probably, this results in deterministic iteration in all browser implementations).\n        let aJson = JSON.stringify(a.toJSON());\n        let bJson = JSON.stringify(b.toJSON());\n        return aJson == bJson;\n    }\n    static equalsMany(a, b) {\n        return a.every((type, i) => type.equals(b[i]));\n    }\n    static isAssignableFromMany(a, b) {\n        return a.every((type, i) => type.isAssignableFrom(b[i]));\n    }\n    differs(other) {\n        return !this.equals(other);\n    }\n    valueOf() {\n        return this.name;\n    }\n    /**\n     * Inspired from: https://docs.microsoft.com/en-us/dotnet/api/system.type.isassignablefrom\n     * For (most) generics, type invariance is expected (assumed) - neither covariance, nor contravariance are supported yet (will be supported in a next release).\n     *\n     * One exception though: for {@link OptionType}, we simulate covariance for missing (not provided) values.\n     * For example, Option<u32> is assignable from Option<?>.\n     * For more details, see the implementation of {@link OptionType}.\n     *\n     * Also see:\n     *  - https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)\n     *  - https://docs.microsoft.com/en-us/dotnet/standard/generics/covariance-and-contravariance\n     */\n    isAssignableFrom(type) {\n        let invariantTypeParameters = Type.equalsMany(this.getTypeParameters(), type.getTypeParameters());\n        return type instanceof this.constructor && invariantTypeParameters;\n    }\n    /**\n     * Converts the account to a pretty, plain JavaScript object.\n     */\n    toJSON() {\n        return {\n            name: this.name,\n            typeParameters: this.typeParameters.map(item => item.toJSON())\n        };\n    }\n    getCardinality() {\n        return this.cardinality;\n    }\n}\nexports.Type = Type;\n/**\n * TODO: Simplify this class, keep only what is needed.\n *\n * An abstraction for defining and operating with the cardinality of a (composite or simple) type.\n *\n * Simple types (the ones that are directly encodable) have a fixed cardinality: [lower = 1, upper = 1].\n * Composite types (not directly encodable) do not follow this constraint. For example:\n *  - VarArgs: [lower = 0, upper = *]\n *  - OptionalResult: [lower = 0, upper = 1]\n */\nclass TypeCardinality {\n    constructor(lowerBound, upperBound) {\n        this.lowerBound = lowerBound;\n        this.upperBound = upperBound;\n    }\n    static fixed(value) {\n        return new TypeCardinality(value, value);\n    }\n    static variable(value) {\n        return new TypeCardinality(0, value);\n    }\n    isSingular() {\n        return this.lowerBound == 1 && this.upperBound == 1;\n    }\n    isSingularOrNone() {\n        return this.lowerBound == 0 && this.upperBound == 1;\n    }\n    isComposite() {\n        return this.upperBound != 1;\n    }\n    isFixed() {\n        return this.lowerBound == this.upperBound;\n    }\n    getLowerBound() {\n        return this.lowerBound;\n    }\n    getUpperBound() {\n        return this.upperBound || TypeCardinality.MaxCardinality;\n    }\n}\nexports.TypeCardinality = TypeCardinality;\n/**\n * An arbitrarily chosen, reasonably large number.\n */\nTypeCardinality.MaxCardinality = 4096;\nclass PrimitiveType extends Type {\n    constructor(name) {\n        super(name);\n    }\n}\nexports.PrimitiveType = PrimitiveType;\nclass CustomType extends Type {\n}\nexports.CustomType = CustomType;\nclass TypedValue {\n    constructor(type) {\n        this.type = type;\n    }\n    getType() {\n        return this.type;\n    }\n}\nexports.TypedValue = TypedValue;\nclass PrimitiveValue extends TypedValue {\n    constructor(type) {\n        super(type);\n    }\n}\nexports.PrimitiveValue = PrimitiveValue;\nfunction isTyped(value) {\n    return value instanceof TypedValue;\n}\nexports.isTyped = isTyped;\nclass TypePlaceholder extends Type {\n    constructor() {\n        super(\"...\");\n    }\n}\nexports.TypePlaceholder = TypePlaceholder;\nclass NullType extends Type {\n    constructor() {\n        super(\"?\");\n    }\n}\nexports.NullType = NullType;\n//# sourceMappingURL=types.js.map"]},"metadata":{},"sourceType":"script"}