{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionWatcher = void 0;\n\nconst asyncTimer_1 = require(\"./asyncTimer\");\n\nconst errors = __importStar(require(\"./errors\"));\n\nconst logger_1 = require(\"./logger\");\n/**\n * TransactionWatcher allows one to continuously watch (monitor), by means of polling, the status of a given transaction.\n */\n\n\nclass TransactionWatcher {\n  /**\n   *\n   * @param hash The hash of the transaction to watch\n   * @param fetcher The transaction fetcher\n   * @param pollingInterval The polling interval, in milliseconds\n   * @param timeout The timeout, in milliseconds\n   */\n  constructor(hash, fetcher) {\n    let pollingInterval = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TransactionWatcher.DefaultPollingInterval;\n    let timeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TransactionWatcher.DefaultTimeout;\n    this.hash = hash;\n    this.fetcher = fetcher;\n    this.pollingInterval = pollingInterval;\n    this.timeout = timeout;\n  }\n  /**\n   * Waits until the transaction reaches the \"pending\" status.\n   */\n\n\n  awaitPending(onStatusReceived) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.awaitStatus(status => status.isPending(), onStatusReceived || TransactionWatcher.NoopOnStatusReceived);\n    });\n  }\n  /**\n    * Waits until the transaction reaches the \"executed\" status.\n    */\n\n\n  awaitExecuted(onStatusReceived) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.awaitStatus(status => status.isExecuted(), onStatusReceived || TransactionWatcher.NoopOnStatusReceived);\n    });\n  }\n  /**\n   * Waits until the predicate over the transaction status evaluates to \"true\".\n   * @param isAwaitedStatus A predicate over the status\n   */\n\n\n  awaitStatus(isAwaitedStatus, onStatusReceived) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let doFetch = () => __awaiter(this, void 0, void 0, function* () {\n        return yield this.fetcher.getTransactionStatus(this.hash);\n      });\n\n      let errorProvider = () => new errors.ErrExpectedTransactionStatusNotReached();\n\n      return this.awaitConditionally(isAwaitedStatus, doFetch, onStatusReceived, errorProvider);\n    });\n  }\n\n  awaitNotarized() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let isNotarized = data => !data.hyperblockHash.isEmpty();\n\n      let doFetch = () => __awaiter(this, void 0, void 0, function* () {\n        return yield this.fetcher.getTransaction(this.hash);\n      });\n\n      let errorProvider = () => new errors.ErrTransactionWatcherTimeout();\n\n      return this.awaitConditionally(isNotarized, doFetch, _ => {}, errorProvider);\n    });\n  }\n\n  awaitConditionally(isSatisfied, doFetch, onFetched, createError) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let periodicTimer = new asyncTimer_1.AsyncTimer(\"watcher:periodic\");\n      let timeoutTimer = new asyncTimer_1.AsyncTimer(\"watcher:timeout\");\n      let stop = false;\n      let fetchedData = undefined;\n\n      let _ = timeoutTimer.start(this.timeout).finally(() => {\n        timeoutTimer.stop();\n        stop = true;\n      });\n\n      while (!stop) {\n        try {\n          fetchedData = yield doFetch();\n          logger_1.Logger.debug(\"TransactionWatcher.awaitConditionally(): fetched data.\", this.hash.toString());\n\n          if (onFetched) {\n            onFetched(fetchedData);\n          }\n\n          if (isSatisfied(fetchedData) || stop) {\n            break;\n          }\n        } catch (error) {\n          logger_1.Logger.info(\"TransactionWatcher.awaitConditionally(): cannot (yet) fetch data.\", this.hash.toString());\n\n          if (!(error instanceof errors.Err)) {\n            throw error;\n          }\n        }\n\n        yield periodicTimer.start(this.pollingInterval);\n      }\n\n      if (!timeoutTimer.isStopped()) {\n        timeoutTimer.stop();\n      }\n\n      let notSatisfied = !fetchedData || !isSatisfied(fetchedData);\n\n      if (notSatisfied) {\n        let error = createError();\n        throw error;\n      }\n    });\n  }\n\n}\n\nexports.TransactionWatcher = TransactionWatcher;\nTransactionWatcher.DefaultPollingInterval = 6000;\nTransactionWatcher.DefaultTimeout = TransactionWatcher.DefaultPollingInterval * 15;\n\nTransactionWatcher.NoopOnStatusReceived = _ => {};","map":{"version":3,"sources":["../src/transactionWatcher.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TransactionWatcher = void 0;\nconst asyncTimer_1 = require(\"./asyncTimer\");\nconst errors = __importStar(require(\"./errors\"));\nconst logger_1 = require(\"./logger\");\n/**\n * TransactionWatcher allows one to continuously watch (monitor), by means of polling, the status of a given transaction.\n */\nclass TransactionWatcher {\n    /**\n     *\n     * @param hash The hash of the transaction to watch\n     * @param fetcher The transaction fetcher\n     * @param pollingInterval The polling interval, in milliseconds\n     * @param timeout The timeout, in milliseconds\n     */\n    constructor(hash, fetcher, pollingInterval = TransactionWatcher.DefaultPollingInterval, timeout = TransactionWatcher.DefaultTimeout) {\n        this.hash = hash;\n        this.fetcher = fetcher;\n        this.pollingInterval = pollingInterval;\n        this.timeout = timeout;\n    }\n    /**\n     * Waits until the transaction reaches the \"pending\" status.\n     */\n    awaitPending(onStatusReceived) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.awaitStatus(status => status.isPending(), onStatusReceived || TransactionWatcher.NoopOnStatusReceived);\n        });\n    }\n    /**\n      * Waits until the transaction reaches the \"executed\" status.\n      */\n    awaitExecuted(onStatusReceived) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.awaitStatus(status => status.isExecuted(), onStatusReceived || TransactionWatcher.NoopOnStatusReceived);\n        });\n    }\n    /**\n     * Waits until the predicate over the transaction status evaluates to \"true\".\n     * @param isAwaitedStatus A predicate over the status\n     */\n    awaitStatus(isAwaitedStatus, onStatusReceived) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let doFetch = () => __awaiter(this, void 0, void 0, function* () { return yield this.fetcher.getTransactionStatus(this.hash); });\n            let errorProvider = () => new errors.ErrExpectedTransactionStatusNotReached();\n            return this.awaitConditionally(isAwaitedStatus, doFetch, onStatusReceived, errorProvider);\n        });\n    }\n    awaitNotarized() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let isNotarized = (data) => !data.hyperblockHash.isEmpty();\n            let doFetch = () => __awaiter(this, void 0, void 0, function* () { return yield this.fetcher.getTransaction(this.hash); });\n            let errorProvider = () => new errors.ErrTransactionWatcherTimeout();\n            return this.awaitConditionally(isNotarized, doFetch, (_) => { }, errorProvider);\n        });\n    }\n    awaitConditionally(isSatisfied, doFetch, onFetched, createError) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let periodicTimer = new asyncTimer_1.AsyncTimer(\"watcher:periodic\");\n            let timeoutTimer = new asyncTimer_1.AsyncTimer(\"watcher:timeout\");\n            let stop = false;\n            let fetchedData = undefined;\n            let _ = timeoutTimer.start(this.timeout).finally(() => {\n                timeoutTimer.stop();\n                stop = true;\n            });\n            while (!stop) {\n                try {\n                    fetchedData = yield doFetch();\n                    logger_1.Logger.debug(\"TransactionWatcher.awaitConditionally(): fetched data.\", this.hash.toString());\n                    if (onFetched) {\n                        onFetched(fetchedData);\n                    }\n                    if (isSatisfied(fetchedData) || stop) {\n                        break;\n                    }\n                }\n                catch (error) {\n                    logger_1.Logger.info(\"TransactionWatcher.awaitConditionally(): cannot (yet) fetch data.\", this.hash.toString());\n                    if (!(error instanceof errors.Err)) {\n                        throw error;\n                    }\n                }\n                yield periodicTimer.start(this.pollingInterval);\n            }\n            if (!timeoutTimer.isStopped()) {\n                timeoutTimer.stop();\n            }\n            let notSatisfied = !fetchedData || !isSatisfied(fetchedData);\n            if (notSatisfied) {\n                let error = createError();\n                throw error;\n            }\n        });\n    }\n}\nexports.TransactionWatcher = TransactionWatcher;\nTransactionWatcher.DefaultPollingInterval = 6000;\nTransactionWatcher.DefaultTimeout = TransactionWatcher.DefaultPollingInterval * 15;\nTransactionWatcher.NoopOnStatusReceived = (_) => { };\n//# sourceMappingURL=transactionWatcher.js.map"]},"metadata":{},"sourceType":"script"}