{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ProtoSerializer = void 0;\n\nvar errors = __importStar(require(\"../errors\"));\n\nvar utils_1 = require(\"../smartcontracts/codec/utils\");\n\nvar compiled_1 = require(\"./compiled\");\n\nvar constants_1 = require(\"../constants\");\n/**\n * Hides away the serialization complexity, for each type of object (e.g. transactions).\n \n * The implementation is non-generic, but practical: there's a pair of `serialize` / `deserialize` method for each type of object.\n */\n\n\nvar ProtoSerializer = /*#__PURE__*/function () {\n  function ProtoSerializer() {\n    _classCallCheck(this, ProtoSerializer);\n  }\n\n  _createClass(ProtoSerializer, [{\n    key: \"serializeTransaction\",\n    value:\n    /**\n     * Serializes a Transaction object to a Buffer. Handles low-level conversion logic and field-mappings as well.\n     */\n    function serializeTransaction(transaction) {\n      var protoTransaction = new compiled_1.proto.Transaction({\n        // elrond-go's serializer handles nonce == 0 differently, thus we treat 0 as \"undefined\".\n        Nonce: transaction.getNonce().valueOf() ? transaction.getNonce().valueOf() : undefined,\n        Value: this.serializeBalance(transaction.getValue()),\n        RcvAddr: transaction.getReceiver().pubkey(),\n        RcvUserName: null,\n        SndAddr: transaction.getSender().pubkey(),\n        SndUserName: null,\n        GasPrice: transaction.getGasPrice().valueOf(),\n        GasLimit: transaction.getGasLimit().valueOf(),\n        Data: transaction.getData().isEmpty() ? null : transaction.getData().valueOf(),\n        ChainID: Buffer.from(transaction.getChainID().valueOf()),\n        Version: transaction.getVersion().valueOf(),\n        Signature: Buffer.from(transaction.getSignature().hex(), \"hex\")\n      });\n\n      if (transaction.getOptions().valueOf() !== constants_1.TRANSACTION_OPTIONS_DEFAULT) {\n        protoTransaction.Options = transaction.getOptions().valueOf();\n      }\n\n      var encoded = compiled_1.proto.Transaction.encode(protoTransaction).finish();\n      var buffer = Buffer.from(encoded);\n      return buffer;\n    }\n    /**\n     * Custom serialization, compatible with elrond-go.\n     */\n\n  }, {\n    key: \"serializeBalance\",\n    value: function serializeBalance(balance) {\n      var value = balance.valueOf();\n\n      if (value.isZero()) {\n        return Buffer.from([0, 0]);\n      } // Will retain the magnitude, as a buffer.\n\n\n      var buffer = utils_1.bigIntToBuffer(value); // We prepend the \"positive\" sign marker, in order to be compatible with Elrond Go's \"sign & magnitude\" proto-representation (a custom one).\n\n      buffer = Buffer.concat([Buffer.from([0x00]), buffer]);\n      return buffer;\n    }\n  }, {\n    key: \"deserializeTransaction\",\n    value: function deserializeTransaction(_buffer) {\n      // Not needed (yet).\n      throw new errors.ErrUnsupportedOperation(\"deserializeTransaction\");\n    }\n  }]);\n\n  return ProtoSerializer;\n}();\n\nexports.ProtoSerializer = ProtoSerializer;","map":{"version":3,"sources":["../../src/proto/serializer.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,MAAA,GAAA,YAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;;AAEA,IAAA,OAAA,GAAA,OAAA,CAAA,+BAAA,CAAA;;AAEA,IAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,cAAA,CAAA;AAEA;;;;AAIG;;;IACU,e;;;;;;;;IACT;;AAEG;IACH,8BAAqB,WAArB,EAA6C;MACzC,IAAI,gBAAgB,GAAG,IAAI,UAAA,CAAA,KAAA,CAAM,WAAV,CAAsB;QACzC;QACA,KAAK,EAAE,WAAW,CAAC,QAAZ,GAAuB,OAAvB,KAAmC,WAAW,CAAC,QAAZ,GAAuB,OAAvB,EAAnC,GAAsE,SAFpC;QAGzC,KAAK,EAAE,KAAK,gBAAL,CAAsB,WAAW,CAAC,QAAZ,EAAtB,CAHkC;QAIzC,OAAO,EAAE,WAAW,CAAC,WAAZ,GAA0B,MAA1B,EAJgC;QAKzC,WAAW,EAAE,IAL4B;QAMzC,OAAO,EAAE,WAAW,CAAC,SAAZ,GAAwB,MAAxB,EANgC;QAOzC,WAAW,EAAE,IAP4B;QAQzC,QAAQ,EAAE,WAAW,CAAC,WAAZ,GAA0B,OAA1B,EAR+B;QASzC,QAAQ,EAAE,WAAW,CAAC,WAAZ,GAA0B,OAA1B,EAT+B;QAUzC,IAAI,EAAE,WAAW,CAAC,OAAZ,GAAsB,OAAtB,KAAkC,IAAlC,GAAyC,WAAW,CAAC,OAAZ,GAAsB,OAAtB,EAVN;QAWzC,OAAO,EAAE,MAAM,CAAC,IAAP,CAAY,WAAW,CAAC,UAAZ,GAAyB,OAAzB,EAAZ,CAXgC;QAYzC,OAAO,EAAE,WAAW,CAAC,UAAZ,GAAyB,OAAzB,EAZgC;QAazC,SAAS,EAAE,MAAM,CAAC,IAAP,CAAY,WAAW,CAAC,YAAZ,GAA2B,GAA3B,EAAZ,EAA8C,KAA9C;MAb8B,CAAtB,CAAvB;;MAgBA,IAAK,WAAW,CAAC,UAAZ,GAAyB,OAAzB,OAAuC,WAAA,CAAA,2BAA5C,EAA0E;QACtE,gBAAgB,CAAC,OAAjB,GAA2B,WAAW,CAAC,UAAZ,GAAyB,OAAzB,EAA3B;MACH;;MAED,IAAI,OAAO,GAAG,UAAA,CAAA,KAAA,CAAM,WAAN,CAAkB,MAAlB,CAAyB,gBAAzB,EAA2C,MAA3C,EAAd;MACA,IAAI,MAAM,GAAG,MAAM,CAAC,IAAP,CAAY,OAAZ,CAAb;MACA,OAAO,MAAP;IACH;IAED;;AAEG;;;;WACK,0BAAiB,OAAjB,EAAiC;MACrC,IAAI,KAAK,GAAG,OAAO,CAAC,OAAR,EAAZ;;MACA,IAAI,KAAK,CAAC,MAAN,EAAJ,EAAoB;QAChB,OAAO,MAAM,CAAC,IAAP,CAAY,CAAC,CAAD,EAAI,CAAJ,CAAZ,CAAP;MACH,CAJoC,CAMrC;;;MACA,IAAI,MAAM,GAAG,OAAA,CAAA,cAAA,CAAe,KAAf,CAAb,CAPqC,CAQrC;;MACA,MAAM,GAAG,MAAM,CAAC,MAAP,CAAc,CAAC,MAAM,CAAC,IAAP,CAAY,CAAC,IAAD,CAAZ,CAAD,EAAsB,MAAtB,CAAd,CAAT;MACA,OAAO,MAAP;IACH;;;WAED,gCAAuB,OAAvB,EAAsC;MAClC;MACA,MAAM,IAAI,MAAM,CAAC,uBAAX,CAAmC,wBAAnC,CAAN;IACH;;;;;;AAjDL,OAAA,CAAA,eAAA,GAAA,eAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProtoSerializer = void 0;\nconst errors = __importStar(require(\"../errors\"));\nconst utils_1 = require(\"../smartcontracts/codec/utils\");\nconst compiled_1 = require(\"./compiled\");\nconst constants_1 = require(\"../constants\");\n/**\n * Hides away the serialization complexity, for each type of object (e.g. transactions).\n \n * The implementation is non-generic, but practical: there's a pair of `serialize` / `deserialize` method for each type of object.\n */\nclass ProtoSerializer {\n    /**\n     * Serializes a Transaction object to a Buffer. Handles low-level conversion logic and field-mappings as well.\n     */\n    serializeTransaction(transaction) {\n        let protoTransaction = new compiled_1.proto.Transaction({\n            // elrond-go's serializer handles nonce == 0 differently, thus we treat 0 as \"undefined\".\n            Nonce: transaction.getNonce().valueOf() ? transaction.getNonce().valueOf() : undefined,\n            Value: this.serializeBalance(transaction.getValue()),\n            RcvAddr: transaction.getReceiver().pubkey(),\n            RcvUserName: null,\n            SndAddr: transaction.getSender().pubkey(),\n            SndUserName: null,\n            GasPrice: transaction.getGasPrice().valueOf(),\n            GasLimit: transaction.getGasLimit().valueOf(),\n            Data: transaction.getData().isEmpty() ? null : transaction.getData().valueOf(),\n            ChainID: Buffer.from(transaction.getChainID().valueOf()),\n            Version: transaction.getVersion().valueOf(),\n            Signature: Buffer.from(transaction.getSignature().hex(), \"hex\")\n        });\n        if (transaction.getOptions().valueOf() !== constants_1.TRANSACTION_OPTIONS_DEFAULT) {\n            protoTransaction.Options = transaction.getOptions().valueOf();\n        }\n        let encoded = compiled_1.proto.Transaction.encode(protoTransaction).finish();\n        let buffer = Buffer.from(encoded);\n        return buffer;\n    }\n    /**\n     * Custom serialization, compatible with elrond-go.\n     */\n    serializeBalance(balance) {\n        let value = balance.valueOf();\n        if (value.isZero()) {\n            return Buffer.from([0, 0]);\n        }\n        // Will retain the magnitude, as a buffer.\n        let buffer = utils_1.bigIntToBuffer(value);\n        // We prepend the \"positive\" sign marker, in order to be compatible with Elrond Go's \"sign & magnitude\" proto-representation (a custom one).\n        buffer = Buffer.concat([Buffer.from([0x00]), buffer]);\n        return buffer;\n    }\n    deserializeTransaction(_buffer) {\n        // Not needed (yet).\n        throw new errors.ErrUnsupportedOperation(\"deserializeTransaction\");\n    }\n}\nexports.ProtoSerializer = ProtoSerializer;\n//# sourceMappingURL=serializer.js.map"]},"metadata":{},"sourceType":"script"}