{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _toConsumableArray = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _classCallCheck = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Interaction = void 0;\n\nvar balance_1 = require(\"../balance\");\n\nvar networkParams_1 = require(\"../networkParams\");\n\nvar query_1 = require(\"./query\");\n\nvar function_1 = require(\"./function\");\n\nvar address_1 = require(\"../address\");\n\nvar typesystem_1 = require(\"./typesystem\");\n\nvar nonce_1 = require(\"../nonce\");\n\nvar networkConfig_1 = require(\"../networkConfig\");\n\nvar constants_1 = require(\"../constants\");\n/**\n * Interactions can be seen as mutable transaction & query builders.\n *\n * Aside from building transactions and queries, the interactors are also responsible for interpreting\n * the execution outcome for the objects they've built.\n */\n\n\nvar Interaction = /*#__PURE__*/function () {\n  function Interaction(contract, executingFunction, interpretingFunction, args, receiver) {\n    _classCallCheck(this, Interaction);\n\n    this.nonce = new nonce_1.Nonce(0);\n    this.value = balance_1.Balance.Zero();\n    this.gasLimit = networkParams_1.GasLimit.min();\n    this.isWithSingleESDTTransfer = false;\n    this.isWithSingleESDTNFTTransfer = false;\n    this.isWithMultiESDTNFTTransfer = false;\n    this.tokenTransfersSender = new address_1.Address();\n    this.contract = contract;\n    this.executingFunction = executingFunction;\n    this.interpretingFunction = interpretingFunction;\n    this.args = args;\n    this.receiver = receiver;\n    this.tokenTransfers = new TokenTransfersWithinInteraction([], this);\n  }\n\n  _createClass(Interaction, [{\n    key: \"getContract\",\n    value: function getContract() {\n      return this.contract;\n    }\n  }, {\n    key: \"getInterpretingFunction\",\n    value: function getInterpretingFunction() {\n      return this.interpretingFunction;\n    }\n  }, {\n    key: \"getExecutingFunction\",\n    value: function getExecutingFunction() {\n      return this.executingFunction;\n    }\n  }, {\n    key: \"getArguments\",\n    value: function getArguments() {\n      return this.args;\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.value;\n    }\n  }, {\n    key: \"getTokenTransfers\",\n    value: function getTokenTransfers() {\n      return this.tokenTransfers.getTransfers();\n    }\n  }, {\n    key: \"getGasLimit\",\n    value: function getGasLimit() {\n      return this.gasLimit;\n    }\n  }, {\n    key: \"buildTransaction\",\n    value: function buildTransaction() {\n      var receiver = this.receiver;\n      var func = this.executingFunction;\n      var args = this.args;\n\n      if (this.isWithSingleESDTTransfer) {\n        func = new function_1.ContractFunction(constants_1.ESDT_TRANSFER_FUNCTION_NAME);\n        args = this.tokenTransfers.buildArgsForSingleESDTTransfer();\n      } else if (this.isWithSingleESDTNFTTransfer) {\n        // For NFT, SFT and MetaESDT, transaction.sender == transaction.receiver.\n        receiver = this.tokenTransfersSender;\n        func = new function_1.ContractFunction(constants_1.ESDTNFT_TRANSFER_FUNCTION_NAME);\n        args = this.tokenTransfers.buildArgsForSingleESDTNFTTransfer();\n      } else if (this.isWithMultiESDTNFTTransfer) {\n        // For NFT, SFT and MetaESDT, transaction.sender == transaction.receiver.\n        receiver = this.tokenTransfersSender;\n        func = new function_1.ContractFunction(constants_1.MULTI_ESDTNFT_TRANSFER_FUNCTION_NAME);\n        args = this.tokenTransfers.buildArgsForMultiESDTNFTTransfer();\n      } // TODO: create as \"deploy\" transaction if the function is \"init\" (or find a better pattern for deployments).\n\n\n      var transaction = this.contract.call({\n        func: func,\n        // GasLimit will be set using \"withGasLimit()\".\n        gasLimit: this.gasLimit,\n        args: args,\n        // Value will be set using \"withValue()\".\n        value: this.value,\n        receiver: receiver\n      });\n      transaction.setNonce(this.nonce);\n      return transaction;\n    }\n  }, {\n    key: \"buildQuery\",\n    value: function buildQuery() {\n      return new query_1.Query({\n        address: this.contract.getAddress(),\n        func: this.executingFunction,\n        args: this.args,\n        // Value will be set using \"withValue()\".\n        value: this.value,\n        // Caller will be set by the InteractionRunner.\n        caller: new address_1.Address()\n      });\n    }\n    /**\n     * Interprets the results of a previously broadcasted (and fully executed) smart contract transaction.\n     * The outcome is structured such that it allows quick access to each level of detail.\n     */\n\n  }, {\n    key: \"interpretExecutionResults\",\n    value: function interpretExecutionResults(transactionOnNetwork) {\n      return _interpretExecutionResults(this.getEndpoint(), transactionOnNetwork);\n    }\n    /**\n     * Interprets the raw outcome of a Smart Contract query.\n     * The outcome is structured such that it allows quick access to each level of detail.\n     */\n\n  }, {\n    key: \"interpretQueryResponse\",\n    value: function interpretQueryResponse(queryResponse) {\n      var endpoint = this.getEndpoint();\n      queryResponse.setEndpointDefinition(endpoint);\n      var values = queryResponse.outputTyped();\n      var returnCode = queryResponse.returnCode;\n      return {\n        queryResponse: queryResponse,\n        values: values,\n        firstValue: values[0],\n        returnCode: returnCode\n      };\n    }\n  }, {\n    key: \"withValue\",\n    value: function withValue(value) {\n      this.value = value;\n      return this;\n    }\n  }, {\n    key: \"withSingleESDTTransfer\",\n    value: function withSingleESDTTransfer(transfer) {\n      this.isWithSingleESDTTransfer = true;\n      this.tokenTransfers = new TokenTransfersWithinInteraction([transfer], this);\n      return this;\n    }\n  }, {\n    key: \"withSingleESDTNFTTransfer\",\n    value: function withSingleESDTNFTTransfer(transfer, sender) {\n      this.isWithSingleESDTNFTTransfer = true;\n      this.tokenTransfers = new TokenTransfersWithinInteraction([transfer], this);\n      this.tokenTransfersSender = sender;\n      return this;\n    }\n  }, {\n    key: \"withMultiESDTNFTTransfer\",\n    value: function withMultiESDTNFTTransfer(transfers, sender) {\n      this.isWithMultiESDTNFTTransfer = true;\n      this.tokenTransfers = new TokenTransfersWithinInteraction(transfers, this);\n      this.tokenTransfersSender = sender;\n      return this;\n    }\n  }, {\n    key: \"withGasLimit\",\n    value: function withGasLimit(gasLimit) {\n      this.gasLimit = gasLimit;\n      return this;\n    }\n  }, {\n    key: \"withGasLimitComponents\",\n    value: function withGasLimitComponents(args) {\n      var minGasLimit = args.minGasLimit || networkConfig_1.NetworkConfig.getDefault().MinGasLimit.valueOf();\n      var gasPerDataByte = args.gasPerDataByte || networkConfig_1.NetworkConfig.getDefault().GasPerDataByte;\n      var transaction = this.buildTransaction();\n      var dataLength = transaction.getData().length();\n      var movementComponent = new networkParams_1.GasLimit(minGasLimit + gasPerDataByte * dataLength);\n      var executionComponent = new networkParams_1.GasLimit(args.estimatedExecutionComponent);\n      var gasLimit = movementComponent.add(executionComponent);\n      return this.withGasLimit(gasLimit);\n    }\n  }, {\n    key: \"withNonce\",\n    value: function withNonce(nonce) {\n      this.nonce = nonce;\n      return this;\n    }\n  }, {\n    key: \"getEndpoint\",\n    value: function getEndpoint() {\n      return this.getContract().getAbi().getEndpoint(this.getInterpretingFunction());\n    }\n  }]);\n\n  return Interaction;\n}();\n\nexports.Interaction = Interaction;\n\nfunction _interpretExecutionResults(endpoint, transactionOnNetwork) {\n  var smartContractResults = transactionOnNetwork.getSmartContractResults();\n  var immediateResult = smartContractResults.getImmediate();\n  var resultingCalls = smartContractResults.getResultingCalls();\n  immediateResult.setEndpointDefinition(endpoint);\n  var values = immediateResult.outputTyped();\n  var returnCode = immediateResult.getReturnCode();\n  return {\n    transactionOnNetwork: transactionOnNetwork,\n    smartContractResults: smartContractResults,\n    immediateResult: immediateResult,\n    resultingCalls: resultingCalls,\n    values: values,\n    firstValue: values[0],\n    returnCode: returnCode\n  };\n}\n\nvar TokenTransfersWithinInteraction = /*#__PURE__*/function () {\n  function TokenTransfersWithinInteraction(transfers, interaction) {\n    _classCallCheck(this, TokenTransfersWithinInteraction);\n\n    this.transfers = transfers;\n    this.interaction = interaction;\n  }\n\n  _createClass(TokenTransfersWithinInteraction, [{\n    key: \"getTransfers\",\n    value: function getTransfers() {\n      return this.transfers;\n    }\n  }, {\n    key: \"buildArgsForSingleESDTTransfer\",\n    value: function buildArgsForSingleESDTTransfer() {\n      var singleTransfer = this.transfers[0];\n      return [this.getTypedTokenIdentifier(singleTransfer), this.getTypedTokenQuantity(singleTransfer), this.getTypedInteractionFunction()].concat(_toConsumableArray(this.getInteractionArguments()));\n    }\n  }, {\n    key: \"buildArgsForSingleESDTNFTTransfer\",\n    value: function buildArgsForSingleESDTNFTTransfer() {\n      var singleTransfer = this.transfers[0];\n      return [this.getTypedTokenIdentifier(singleTransfer), this.getTypedTokenNonce(singleTransfer), this.getTypedTokenQuantity(singleTransfer), this.getTypedTokensReceiver(), this.getTypedInteractionFunction()].concat(_toConsumableArray(this.getInteractionArguments()));\n    }\n  }, {\n    key: \"buildArgsForMultiESDTNFTTransfer\",\n    value: function buildArgsForMultiESDTNFTTransfer() {\n      var result = [];\n      result.push(this.getTypedTokensReceiver());\n      result.push(this.getTypedNumberOfTransfers());\n\n      var _iterator = _createForOfIteratorHelper(this.transfers),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var transfer = _step.value;\n          result.push(this.getTypedTokenIdentifier(transfer));\n          result.push(this.getTypedTokenNonce(transfer));\n          result.push(this.getTypedTokenQuantity(transfer));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      result.push(this.getTypedInteractionFunction());\n      result.push.apply(result, _toConsumableArray(this.getInteractionArguments()));\n      return result;\n    }\n  }, {\n    key: \"getTypedNumberOfTransfers\",\n    value: function getTypedNumberOfTransfers() {\n      return new typesystem_1.U8Value(this.transfers.length);\n    }\n  }, {\n    key: \"getTypedTokenIdentifier\",\n    value: function getTypedTokenIdentifier(transfer) {\n      // Important: for NFTs, this has to be the \"collection\" name, actually.\n      // We will reconsider adding the field \"collection\" on \"Token\" upon merging \"ApiProvider\" and \"ProxyProvider\".\n      return typesystem_1.BytesValue.fromUTF8(transfer.token.identifier);\n    }\n  }, {\n    key: \"getTypedTokenNonce\",\n    value: function getTypedTokenNonce(transfer) {\n      // The token nonce (creation nonce)\n      return new typesystem_1.U64Value(transfer.getNonce());\n    }\n  }, {\n    key: \"getTypedTokenQuantity\",\n    value: function getTypedTokenQuantity(transfer) {\n      // For NFTs, this will be 1.\n      return new typesystem_1.BigUIntValue(transfer.valueOf());\n    }\n  }, {\n    key: \"getTypedTokensReceiver\",\n    value: function getTypedTokensReceiver() {\n      // The actual receiver of the token(s): the contract\n      return new typesystem_1.AddressValue(this.interaction.getContract().getAddress());\n    }\n  }, {\n    key: \"getTypedInteractionFunction\",\n    value: function getTypedInteractionFunction() {\n      return typesystem_1.BytesValue.fromUTF8(this.interaction.getExecutingFunction().valueOf());\n    }\n  }, {\n    key: \"getInteractionArguments\",\n    value: function getInteractionArguments() {\n      return this.interaction.getArguments();\n    }\n  }]);\n\n  return TokenTransfersWithinInteraction;\n}();","map":{"version":3,"sources":["../../src/smartcontracts/interaction.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Interaction = void 0;\nconst balance_1 = require(\"../balance\");\nconst networkParams_1 = require(\"../networkParams\");\nconst query_1 = require(\"./query\");\nconst function_1 = require(\"./function\");\nconst address_1 = require(\"../address\");\nconst typesystem_1 = require(\"./typesystem\");\nconst nonce_1 = require(\"../nonce\");\nconst networkConfig_1 = require(\"../networkConfig\");\nconst constants_1 = require(\"../constants\");\n/**\n * Interactions can be seen as mutable transaction & query builders.\n *\n * Aside from building transactions and queries, the interactors are also responsible for interpreting\n * the execution outcome for the objects they've built.\n */\nclass Interaction {\n    constructor(contract, executingFunction, interpretingFunction, args, receiver) {\n        this.nonce = new nonce_1.Nonce(0);\n        this.value = balance_1.Balance.Zero();\n        this.gasLimit = networkParams_1.GasLimit.min();\n        this.isWithSingleESDTTransfer = false;\n        this.isWithSingleESDTNFTTransfer = false;\n        this.isWithMultiESDTNFTTransfer = false;\n        this.tokenTransfersSender = new address_1.Address();\n        this.contract = contract;\n        this.executingFunction = executingFunction;\n        this.interpretingFunction = interpretingFunction;\n        this.args = args;\n        this.receiver = receiver;\n        this.tokenTransfers = new TokenTransfersWithinInteraction([], this);\n    }\n    getContract() {\n        return this.contract;\n    }\n    getInterpretingFunction() {\n        return this.interpretingFunction;\n    }\n    getExecutingFunction() {\n        return this.executingFunction;\n    }\n    getArguments() {\n        return this.args;\n    }\n    getValue() {\n        return this.value;\n    }\n    getTokenTransfers() {\n        return this.tokenTransfers.getTransfers();\n    }\n    getGasLimit() {\n        return this.gasLimit;\n    }\n    buildTransaction() {\n        let receiver = this.receiver;\n        let func = this.executingFunction;\n        let args = this.args;\n        if (this.isWithSingleESDTTransfer) {\n            func = new function_1.ContractFunction(constants_1.ESDT_TRANSFER_FUNCTION_NAME);\n            args = this.tokenTransfers.buildArgsForSingleESDTTransfer();\n        }\n        else if (this.isWithSingleESDTNFTTransfer) {\n            // For NFT, SFT and MetaESDT, transaction.sender == transaction.receiver.\n            receiver = this.tokenTransfersSender;\n            func = new function_1.ContractFunction(constants_1.ESDTNFT_TRANSFER_FUNCTION_NAME);\n            args = this.tokenTransfers.buildArgsForSingleESDTNFTTransfer();\n        }\n        else if (this.isWithMultiESDTNFTTransfer) {\n            // For NFT, SFT and MetaESDT, transaction.sender == transaction.receiver.\n            receiver = this.tokenTransfersSender;\n            func = new function_1.ContractFunction(constants_1.MULTI_ESDTNFT_TRANSFER_FUNCTION_NAME);\n            args = this.tokenTransfers.buildArgsForMultiESDTNFTTransfer();\n        }\n        // TODO: create as \"deploy\" transaction if the function is \"init\" (or find a better pattern for deployments).\n        let transaction = this.contract.call({\n            func: func,\n            // GasLimit will be set using \"withGasLimit()\".\n            gasLimit: this.gasLimit,\n            args: args,\n            // Value will be set using \"withValue()\".\n            value: this.value,\n            receiver: receiver,\n        });\n        transaction.setNonce(this.nonce);\n        return transaction;\n    }\n    buildQuery() {\n        return new query_1.Query({\n            address: this.contract.getAddress(),\n            func: this.executingFunction,\n            args: this.args,\n            // Value will be set using \"withValue()\".\n            value: this.value,\n            // Caller will be set by the InteractionRunner.\n            caller: new address_1.Address()\n        });\n    }\n    /**\n     * Interprets the results of a previously broadcasted (and fully executed) smart contract transaction.\n     * The outcome is structured such that it allows quick access to each level of detail.\n     */\n    interpretExecutionResults(transactionOnNetwork) {\n        return interpretExecutionResults(this.getEndpoint(), transactionOnNetwork);\n    }\n    /**\n     * Interprets the raw outcome of a Smart Contract query.\n     * The outcome is structured such that it allows quick access to each level of detail.\n     */\n    interpretQueryResponse(queryResponse) {\n        let endpoint = this.getEndpoint();\n        queryResponse.setEndpointDefinition(endpoint);\n        let values = queryResponse.outputTyped();\n        let returnCode = queryResponse.returnCode;\n        return {\n            queryResponse: queryResponse,\n            values: values,\n            firstValue: values[0],\n            returnCode: returnCode\n        };\n    }\n    withValue(value) {\n        this.value = value;\n        return this;\n    }\n    withSingleESDTTransfer(transfer) {\n        this.isWithSingleESDTTransfer = true;\n        this.tokenTransfers = new TokenTransfersWithinInteraction([transfer], this);\n        return this;\n    }\n    withSingleESDTNFTTransfer(transfer, sender) {\n        this.isWithSingleESDTNFTTransfer = true;\n        this.tokenTransfers = new TokenTransfersWithinInteraction([transfer], this);\n        this.tokenTransfersSender = sender;\n        return this;\n    }\n    withMultiESDTNFTTransfer(transfers, sender) {\n        this.isWithMultiESDTNFTTransfer = true;\n        this.tokenTransfers = new TokenTransfersWithinInteraction(transfers, this);\n        this.tokenTransfersSender = sender;\n        return this;\n    }\n    withGasLimit(gasLimit) {\n        this.gasLimit = gasLimit;\n        return this;\n    }\n    withGasLimitComponents(args) {\n        let minGasLimit = args.minGasLimit || networkConfig_1.NetworkConfig.getDefault().MinGasLimit.valueOf();\n        let gasPerDataByte = args.gasPerDataByte || networkConfig_1.NetworkConfig.getDefault().GasPerDataByte;\n        let transaction = this.buildTransaction();\n        let dataLength = transaction.getData().length();\n        let movementComponent = new networkParams_1.GasLimit(minGasLimit + gasPerDataByte * dataLength);\n        let executionComponent = new networkParams_1.GasLimit(args.estimatedExecutionComponent);\n        let gasLimit = movementComponent.add(executionComponent);\n        return this.withGasLimit(gasLimit);\n    }\n    withNonce(nonce) {\n        this.nonce = nonce;\n        return this;\n    }\n    getEndpoint() {\n        return this.getContract().getAbi().getEndpoint(this.getInterpretingFunction());\n    }\n}\nexports.Interaction = Interaction;\nfunction interpretExecutionResults(endpoint, transactionOnNetwork) {\n    let smartContractResults = transactionOnNetwork.getSmartContractResults();\n    let immediateResult = smartContractResults.getImmediate();\n    let resultingCalls = smartContractResults.getResultingCalls();\n    immediateResult.setEndpointDefinition(endpoint);\n    let values = immediateResult.outputTyped();\n    let returnCode = immediateResult.getReturnCode();\n    return {\n        transactionOnNetwork: transactionOnNetwork,\n        smartContractResults: smartContractResults,\n        immediateResult,\n        resultingCalls,\n        values,\n        firstValue: values[0],\n        returnCode: returnCode\n    };\n}\nclass TokenTransfersWithinInteraction {\n    constructor(transfers, interaction) {\n        this.transfers = transfers;\n        this.interaction = interaction;\n    }\n    getTransfers() {\n        return this.transfers;\n    }\n    buildArgsForSingleESDTTransfer() {\n        let singleTransfer = this.transfers[0];\n        return [\n            this.getTypedTokenIdentifier(singleTransfer),\n            this.getTypedTokenQuantity(singleTransfer),\n            this.getTypedInteractionFunction(),\n            ...this.getInteractionArguments()\n        ];\n    }\n    buildArgsForSingleESDTNFTTransfer() {\n        let singleTransfer = this.transfers[0];\n        return [\n            this.getTypedTokenIdentifier(singleTransfer),\n            this.getTypedTokenNonce(singleTransfer),\n            this.getTypedTokenQuantity(singleTransfer),\n            this.getTypedTokensReceiver(),\n            this.getTypedInteractionFunction(),\n            ...this.getInteractionArguments()\n        ];\n    }\n    buildArgsForMultiESDTNFTTransfer() {\n        let result = [];\n        result.push(this.getTypedTokensReceiver());\n        result.push(this.getTypedNumberOfTransfers());\n        for (const transfer of this.transfers) {\n            result.push(this.getTypedTokenIdentifier(transfer));\n            result.push(this.getTypedTokenNonce(transfer));\n            result.push(this.getTypedTokenQuantity(transfer));\n        }\n        result.push(this.getTypedInteractionFunction());\n        result.push(...this.getInteractionArguments());\n        return result;\n    }\n    getTypedNumberOfTransfers() {\n        return new typesystem_1.U8Value(this.transfers.length);\n    }\n    getTypedTokenIdentifier(transfer) {\n        // Important: for NFTs, this has to be the \"collection\" name, actually.\n        // We will reconsider adding the field \"collection\" on \"Token\" upon merging \"ApiProvider\" and \"ProxyProvider\".\n        return typesystem_1.BytesValue.fromUTF8(transfer.token.identifier);\n    }\n    getTypedTokenNonce(transfer) {\n        // The token nonce (creation nonce)\n        return new typesystem_1.U64Value(transfer.getNonce());\n    }\n    getTypedTokenQuantity(transfer) {\n        // For NFTs, this will be 1.\n        return new typesystem_1.BigUIntValue(transfer.valueOf());\n    }\n    getTypedTokensReceiver() {\n        // The actual receiver of the token(s): the contract\n        return new typesystem_1.AddressValue(this.interaction.getContract().getAddress());\n    }\n    getTypedInteractionFunction() {\n        return typesystem_1.BytesValue.fromUTF8(this.interaction.getExecutingFunction().valueOf());\n    }\n    getInteractionArguments() {\n        return this.interaction.getArguments();\n    }\n}\n//# sourceMappingURL=interaction.js.map"]},"metadata":{},"sourceType":"script"}