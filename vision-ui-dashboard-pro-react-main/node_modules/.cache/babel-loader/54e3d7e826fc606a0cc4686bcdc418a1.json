{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletProvider = void 0;\n\nconst qs_1 = __importDefault(require(\"qs\"));\n\nconst constants_1 = require(\"./constants\");\n\nconst transaction_1 = require(\"../transaction\");\n\nconst errors_1 = require(\"../errors\");\n\nconst __1 = require(\"../\");\n\nconst signature_1 = require(\"../signature\");\n\nclass WalletProvider {\n  /**\n   * Creates a new WalletProvider\n   * @param walletURL\n   */\n  constructor() {\n    let walletURL = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    this.walletUrl = walletURL;\n  }\n  /**\n   * Waits for the wallet iframe to ping that it has been initialised\n   */\n\n\n  init() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return true;\n    });\n  }\n  /**\n   * Returns if the wallet iframe is up and running\n   */\n\n\n  isInitialized() {\n    return true;\n  }\n  /**\n   * Unlike isInitialized, isConnected returns true if the user alredy went through the login process\n   *  and has the wallet session active\n   */\n\n\n  isConnected() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return false;\n    });\n  }\n  /**\n   * Fetches the login hook url and redirects the client to the wallet login.\n   */\n\n\n  login(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let callbackUrl = `callbackUrl=${window.location.href}`;\n\n      if (options && options.callbackUrl) {\n        callbackUrl = `callbackUrl=${options.callbackUrl}`;\n      }\n\n      let token = '';\n\n      if (options && options.token) {\n        token = `&token=${options.token}`;\n      }\n\n      const redirect = `${this.baseWalletUrl()}${constants_1.WALLET_PROVIDER_CONNECT_URL}?${callbackUrl}${token}`;\n      yield new Promise(resolve => {\n        setTimeout(() => {\n          window.location.href = redirect;\n          resolve(true);\n        }, 10);\n      });\n      return window.location.href;\n    });\n  }\n  /**\n  * Fetches the logout hook url and redirects the client to the wallet logout.\n  */\n\n\n  logout(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let callbackUrl = `callbackUrl=${window.location.href}`;\n\n      if (options && options.callbackUrl) {\n        callbackUrl = `callbackUrl=${options.callbackUrl}`;\n      }\n\n      const redirect = `${this.baseWalletUrl()}${constants_1.WALLET_PROVIDER_DISCONNECT_URL}?${callbackUrl}`;\n      yield new Promise(resolve => {\n        setTimeout(() => {\n          window.location.href = redirect;\n          resolve(true);\n        }, 10);\n      });\n      return true;\n    });\n  }\n  /**\n   * Returns currently connected address. Empty string if not connected\n   */\n\n\n  getAddress() {\n    return __awaiter(this, void 0, void 0, function* () {\n      throw new errors_1.ErrNotImplemented();\n    });\n  }\n  /**\n   * Packs a {@link Transaction} and fetches correct redirect URL from the wallet API. Then redirects\n   *   the client to the send transaction hook\n   * @param transaction\n   * @param options\n   */\n\n\n  sendTransaction(transaction, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let plainTransaction = WalletProvider.prepareWalletTransaction(transaction);\n      let url = `${this.baseWalletUrl()}${constants_1.WALLET_PROVIDER_SEND_TRANSACTION_URL}?${this.buildTransactionUrl(plainTransaction)}`;\n      window.location.href = `${url}&callbackUrl=${options !== undefined && options.callbackUrl !== undefined ? options.callbackUrl : window.location.href}`;\n      return transaction;\n    });\n  }\n  /**\n   * Packs an array of {$link Transaction} and redirects to the correct transaction sigining hook\n   *\n   * @param transactions\n   * @param options\n   */\n\n\n  signTransactions(transactions, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const jsonToSend = {};\n      transactions.map(tx => {\n        let plainTx = WalletProvider.prepareWalletTransaction(tx);\n\n        for (let txProp in plainTx) {\n          if (plainTx.hasOwnProperty(txProp) && !jsonToSend.hasOwnProperty(txProp)) {\n            jsonToSend[txProp] = [];\n          }\n\n          jsonToSend[txProp].push(plainTx[txProp]);\n        }\n      });\n      let url = `${this.baseWalletUrl()}${constants_1.WALLET_PROVIDER_SIGN_TRANSACTION_URL}?${qs_1.default.stringify(jsonToSend)}`;\n      window.location.href = `${url}&callbackUrl=${options !== undefined && options.callbackUrl !== undefined ? options.callbackUrl : window.location.href}`;\n      return transactions;\n    });\n  }\n  /**\n   * Packs a {@link Transaction} and fetches correct redirect URL from the wallet API. Then redirects\n   *   the client to the sign transaction hook\n   * @param transaction\n   * @param options\n   */\n\n\n  signTransaction(transaction, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let plainTransaction = WalletProvider.prepareWalletTransaction(transaction);\n      let url = `${this.baseWalletUrl()}${constants_1.WALLET_PROVIDER_SIGN_TRANSACTION_URL}?${this.buildTransactionUrl(plainTransaction)}`;\n      window.location.href = `${url}&callbackUrl=${options !== undefined && options.callbackUrl !== undefined ? options.callbackUrl : window.location.href}`;\n      return transaction;\n    });\n  }\n\n  getTransactionsFromWalletUrl() {\n    const transactions = [];\n    const urlParams = qs_1.default.parse(window.location.search.slice(1));\n\n    if (!WalletProvider.isTxSignReturnSuccess(urlParams)) {\n      return transactions;\n    }\n\n    return WalletProvider.getTxSignReturnValue(urlParams);\n  }\n  /**\n   * Method will be available once the ElrondWallet hook will be implemented\n   * @param _\n   */\n\n\n  signMessage(_) {\n    return __awaiter(this, void 0, void 0, function* () {\n      throw new errors_1.ErrNotImplemented();\n    });\n  }\n\n  static isTxSignReturnSuccess(urlParams) {\n    return urlParams.hasOwnProperty(constants_1.WALLET_PROVIDER_CALLBACK_PARAM) && urlParams[constants_1.WALLET_PROVIDER_CALLBACK_PARAM] === constants_1.WALLET_PROVIDER_CALLBACK_PARAM_TX_SIGNED;\n  }\n\n  static getTxSignReturnValue(urlParams) {\n    const expectedProps = [\"nonce\", \"value\", \"receiver\", \"sender\", \"gasPrice\", \"gasLimit\", \"data\", \"chainID\", \"version\", \"signature\"];\n\n    for (let txProp of expectedProps) {\n      if (!urlParams[txProp] || !Array.isArray(urlParams[txProp])) {\n        throw new errors_1.ErrInvalidTxSignReturnValue();\n      }\n    }\n\n    const expectedLength = urlParams[\"nonce\"].length;\n\n    for (let txProp of expectedProps) {\n      if (urlParams[txProp].length !== expectedLength) {\n        throw new errors_1.ErrInvalidTxSignReturnValue();\n      }\n    }\n\n    const transactions = [];\n\n    for (let i = 0; i < expectedLength; i++) {\n      let tx = new transaction_1.Transaction({\n        nonce: new __1.Nonce(urlParams[\"nonce\"][i]),\n        value: __1.Balance.fromString(urlParams[\"value\"][i]),\n        receiver: __1.Address.fromString(urlParams[\"receiver\"][i]),\n        gasPrice: new __1.GasPrice(parseInt(urlParams[\"gasPrice\"][i])),\n        gasLimit: new __1.GasLimit(parseInt(urlParams[\"gasLimit\"][i])),\n        data: new __1.TransactionPayload(urlParams[\"data\"][i]),\n        chainID: new __1.ChainID(urlParams[\"chainID\"][i]),\n        version: new __1.TransactionVersion(parseInt(urlParams[\"version\"][i]))\n      });\n      tx.applySignature(new signature_1.Signature(urlParams[\"signature\"][i]), __1.Address.fromString(urlParams[\"sender\"][i]));\n      transactions.push(tx);\n    }\n\n    return transactions;\n  }\n\n  static prepareWalletTransaction(transaction) {\n    let plainTransaction = transaction.toPlainObject(); // We adjust the fields, in order to make them compatible with what the wallet expected\n\n    plainTransaction[\"nonce\"] = transaction.getNonce().valueOf();\n    plainTransaction[\"data\"] = transaction.getData().valueOf().toString();\n    plainTransaction[\"value\"] = transaction.getValue().toString();\n    plainTransaction[\"gasPrice\"] = transaction.getGasPrice().valueOf();\n    plainTransaction[\"gasLimit\"] = transaction.getGasLimit().valueOf();\n    return plainTransaction;\n  }\n\n  buildTransactionUrl(transaction) {\n    let urlString = `receiver=${transaction.receiver}&value=${transaction.value}`;\n\n    if (transaction.gasLimit) {\n      urlString += `&gasLimit=${transaction.gasLimit}`;\n    }\n\n    if (transaction.gasPrice) {\n      urlString += `&gasPrice=${transaction.gasPrice}`;\n    }\n\n    if (transaction.data) {\n      urlString += `&data=${transaction.data}`;\n    }\n\n    if (transaction.nonce) {\n      urlString += `&nonce=${transaction.nonce}`;\n    }\n\n    return urlString;\n  }\n\n  baseWalletUrl() {\n    const pathArray = this.walletUrl.split('/');\n    const protocol = pathArray[0];\n    const host = pathArray[2];\n    return protocol + '//' + host;\n  }\n\n}\n\nexports.WalletProvider = WalletProvider;","map":{"version":3,"sources":["../../src/dapp/walletProvider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WalletProvider = void 0;\nconst qs_1 = __importDefault(require(\"qs\"));\nconst constants_1 = require(\"./constants\");\nconst transaction_1 = require(\"../transaction\");\nconst errors_1 = require(\"../errors\");\nconst __1 = require(\"../\");\nconst signature_1 = require(\"../signature\");\nclass WalletProvider {\n    /**\n     * Creates a new WalletProvider\n     * @param walletURL\n     */\n    constructor(walletURL = '') {\n        this.walletUrl = walletURL;\n    }\n    /**\n     * Waits for the wallet iframe to ping that it has been initialised\n     */\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return true;\n        });\n    }\n    /**\n     * Returns if the wallet iframe is up and running\n     */\n    isInitialized() {\n        return true;\n    }\n    /**\n     * Unlike isInitialized, isConnected returns true if the user alredy went through the login process\n     *  and has the wallet session active\n     */\n    isConnected() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return false;\n        });\n    }\n    /**\n     * Fetches the login hook url and redirects the client to the wallet login.\n     */\n    login(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let callbackUrl = `callbackUrl=${window.location.href}`;\n            if (options && options.callbackUrl) {\n                callbackUrl = `callbackUrl=${options.callbackUrl}`;\n            }\n            let token = '';\n            if (options && options.token) {\n                token = `&token=${options.token}`;\n            }\n            const redirect = `${this.baseWalletUrl()}${constants_1.WALLET_PROVIDER_CONNECT_URL}?${callbackUrl}${token}`;\n            yield new Promise((resolve) => {\n                setTimeout(() => {\n                    window.location.href = redirect;\n                    resolve(true);\n                }, 10);\n            });\n            return window.location.href;\n        });\n    }\n    /**\n    * Fetches the logout hook url and redirects the client to the wallet logout.\n    */\n    logout(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let callbackUrl = `callbackUrl=${window.location.href}`;\n            if (options && options.callbackUrl) {\n                callbackUrl = `callbackUrl=${options.callbackUrl}`;\n            }\n            const redirect = `${this.baseWalletUrl()}${constants_1.WALLET_PROVIDER_DISCONNECT_URL}?${callbackUrl}`;\n            yield new Promise((resolve) => {\n                setTimeout(() => {\n                    window.location.href = redirect;\n                    resolve(true);\n                }, 10);\n            });\n            return true;\n        });\n    }\n    /**\n     * Returns currently connected address. Empty string if not connected\n     */\n    getAddress() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new errors_1.ErrNotImplemented();\n        });\n    }\n    /**\n     * Packs a {@link Transaction} and fetches correct redirect URL from the wallet API. Then redirects\n     *   the client to the send transaction hook\n     * @param transaction\n     * @param options\n     */\n    sendTransaction(transaction, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let plainTransaction = WalletProvider.prepareWalletTransaction(transaction);\n            let url = `${this.baseWalletUrl()}${constants_1.WALLET_PROVIDER_SEND_TRANSACTION_URL}?${this.buildTransactionUrl(plainTransaction)}`;\n            window.location.href = `${url}&callbackUrl=${options !== undefined && options.callbackUrl !== undefined ? options.callbackUrl : window.location.href}`;\n            return transaction;\n        });\n    }\n    /**\n     * Packs an array of {$link Transaction} and redirects to the correct transaction sigining hook\n     *\n     * @param transactions\n     * @param options\n     */\n    signTransactions(transactions, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const jsonToSend = {};\n            transactions.map(tx => {\n                let plainTx = WalletProvider.prepareWalletTransaction(tx);\n                for (let txProp in plainTx) {\n                    if (plainTx.hasOwnProperty(txProp) && !jsonToSend.hasOwnProperty(txProp)) {\n                        jsonToSend[txProp] = [];\n                    }\n                    jsonToSend[txProp].push(plainTx[txProp]);\n                }\n            });\n            let url = `${this.baseWalletUrl()}${constants_1.WALLET_PROVIDER_SIGN_TRANSACTION_URL}?${qs_1.default.stringify(jsonToSend)}`;\n            window.location.href = `${url}&callbackUrl=${options !== undefined && options.callbackUrl !== undefined ? options.callbackUrl : window.location.href}`;\n            return transactions;\n        });\n    }\n    /**\n     * Packs a {@link Transaction} and fetches correct redirect URL from the wallet API. Then redirects\n     *   the client to the sign transaction hook\n     * @param transaction\n     * @param options\n     */\n    signTransaction(transaction, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let plainTransaction = WalletProvider.prepareWalletTransaction(transaction);\n            let url = `${this.baseWalletUrl()}${constants_1.WALLET_PROVIDER_SIGN_TRANSACTION_URL}?${this.buildTransactionUrl(plainTransaction)}`;\n            window.location.href = `${url}&callbackUrl=${options !== undefined && options.callbackUrl !== undefined ? options.callbackUrl : window.location.href}`;\n            return transaction;\n        });\n    }\n    getTransactionsFromWalletUrl() {\n        const transactions = [];\n        const urlParams = qs_1.default.parse(window.location.search.slice(1));\n        if (!WalletProvider.isTxSignReturnSuccess(urlParams)) {\n            return transactions;\n        }\n        return WalletProvider.getTxSignReturnValue(urlParams);\n    }\n    /**\n     * Method will be available once the ElrondWallet hook will be implemented\n     * @param _\n     */\n    signMessage(_) {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new errors_1.ErrNotImplemented();\n        });\n    }\n    static isTxSignReturnSuccess(urlParams) {\n        return urlParams.hasOwnProperty(constants_1.WALLET_PROVIDER_CALLBACK_PARAM) && urlParams[constants_1.WALLET_PROVIDER_CALLBACK_PARAM] === constants_1.WALLET_PROVIDER_CALLBACK_PARAM_TX_SIGNED;\n    }\n    static getTxSignReturnValue(urlParams) {\n        const expectedProps = [\"nonce\", \"value\", \"receiver\", \"sender\", \"gasPrice\",\n            \"gasLimit\", \"data\", \"chainID\", \"version\", \"signature\"];\n        for (let txProp of expectedProps) {\n            if (!urlParams[txProp] || !Array.isArray(urlParams[txProp])) {\n                throw new errors_1.ErrInvalidTxSignReturnValue();\n            }\n        }\n        const expectedLength = urlParams[\"nonce\"].length;\n        for (let txProp of expectedProps) {\n            if (urlParams[txProp].length !== expectedLength) {\n                throw new errors_1.ErrInvalidTxSignReturnValue();\n            }\n        }\n        const transactions = [];\n        for (let i = 0; i < expectedLength; i++) {\n            let tx = new transaction_1.Transaction({\n                nonce: new __1.Nonce(urlParams[\"nonce\"][i]),\n                value: __1.Balance.fromString(urlParams[\"value\"][i]),\n                receiver: __1.Address.fromString(urlParams[\"receiver\"][i]),\n                gasPrice: new __1.GasPrice(parseInt(urlParams[\"gasPrice\"][i])),\n                gasLimit: new __1.GasLimit(parseInt(urlParams[\"gasLimit\"][i])),\n                data: new __1.TransactionPayload(urlParams[\"data\"][i]),\n                chainID: new __1.ChainID(urlParams[\"chainID\"][i]),\n                version: new __1.TransactionVersion(parseInt(urlParams[\"version\"][i])),\n            });\n            tx.applySignature(new signature_1.Signature(urlParams[\"signature\"][i]), __1.Address.fromString(urlParams[\"sender\"][i]));\n            transactions.push(tx);\n        }\n        return transactions;\n    }\n    static prepareWalletTransaction(transaction) {\n        let plainTransaction = transaction.toPlainObject();\n        // We adjust the fields, in order to make them compatible with what the wallet expected\n        plainTransaction[\"nonce\"] = transaction.getNonce().valueOf();\n        plainTransaction[\"data\"] = transaction.getData().valueOf().toString();\n        plainTransaction[\"value\"] = transaction.getValue().toString();\n        plainTransaction[\"gasPrice\"] = transaction.getGasPrice().valueOf();\n        plainTransaction[\"gasLimit\"] = transaction.getGasLimit().valueOf();\n        return plainTransaction;\n    }\n    buildTransactionUrl(transaction) {\n        let urlString = `receiver=${transaction.receiver}&value=${transaction.value}`;\n        if (transaction.gasLimit) {\n            urlString += `&gasLimit=${transaction.gasLimit}`;\n        }\n        if (transaction.gasPrice) {\n            urlString += `&gasPrice=${transaction.gasPrice}`;\n        }\n        if (transaction.data) {\n            urlString += `&data=${transaction.data}`;\n        }\n        if (transaction.nonce) {\n            urlString += `&nonce=${transaction.nonce}`;\n        }\n        return urlString;\n    }\n    baseWalletUrl() {\n        const pathArray = this.walletUrl.split('/');\n        const protocol = pathArray[0];\n        const host = pathArray[2];\n        return protocol + '//' + host;\n    }\n}\nexports.WalletProvider = WalletProvider;\n//# sourceMappingURL=walletProvider.js.map"]},"metadata":{},"sourceType":"script"}