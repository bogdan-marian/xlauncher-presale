{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EnumValue = exports.EnumVariantDefinition = exports.EnumType = void 0;\n\nconst utils_1 = require(\"../../utils\");\n\nconst fields_1 = require(\"./fields\");\n\nconst types_1 = require(\"./types\");\n\nconst SimpleEnumMaxDiscriminant = 256;\n\nclass EnumType extends types_1.CustomType {\n  constructor(name, variants) {\n    super(name);\n    this.variants = [];\n    this.variants = variants;\n  }\n\n  static fromJSON(json) {\n    let variants = (json.variants || []).map(variant => EnumVariantDefinition.fromJSON(variant));\n    return new EnumType(json.name, variants);\n  }\n\n  getVariantByDiscriminant(discriminant) {\n    let result = this.variants.find(e => e.discriminant == discriminant);\n    utils_1.guardValueIsSet(`variant by discriminant (${discriminant})`, result);\n    return result;\n  }\n\n  getVariantByName(name) {\n    let result = this.variants.find(e => e.name == name);\n    utils_1.guardValueIsSet(`variant by name (${name})`, result);\n    return result;\n  }\n\n}\n\nexports.EnumType = EnumType;\n\nclass EnumVariantDefinition {\n  constructor(name, discriminant) {\n    let fieldsDefinitions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    this.fieldsDefinitions = [];\n    utils_1.guardTrue(discriminant < SimpleEnumMaxDiscriminant, `discriminant for simple enum should be less than ${SimpleEnumMaxDiscriminant}`);\n    this.name = name;\n    this.discriminant = discriminant;\n    this.fieldsDefinitions = fieldsDefinitions;\n  }\n\n  static fromJSON(json) {\n    let definitions = (json.fields || []).map(definition => fields_1.FieldDefinition.fromJSON(definition));\n    return new EnumVariantDefinition(json.name, json.discriminant, definitions);\n  }\n\n  getFieldsDefinitions() {\n    return this.fieldsDefinitions;\n  }\n\n}\n\nexports.EnumVariantDefinition = EnumVariantDefinition;\n\nclass EnumValue extends types_1.TypedValue {\n  constructor(type, variant, fields) {\n    super(type);\n    this.fields = [];\n    this.name = variant.name;\n    this.discriminant = variant.discriminant;\n    this.fields = fields;\n    let definitions = variant.getFieldsDefinitions();\n    fields_1.Fields.checkTyping(this.fields, definitions);\n  }\n  /**\n   * Utility (named constructor) to create a simple (i.e. without fields) enum value.\n   */\n\n\n  static fromName(type, name) {\n    let variant = type.getVariantByName(name);\n    return new EnumValue(type, variant, []);\n  }\n  /**\n   * Utility (named constructor) to create a simple (i.e. without fields) enum value.\n   */\n\n\n  static fromDiscriminant(type, discriminant) {\n    let variant = type.getVariantByDiscriminant(discriminant);\n    return new EnumValue(type, variant, []);\n  }\n\n  equals(other) {\n    if (!this.getType().equals(other.getType())) {\n      return false;\n    }\n\n    let selfFields = this.getFields();\n    let otherFields = other.getFields();\n    const nameIsSame = this.name == other.name;\n    const discriminantIsSame = this.discriminant == other.discriminant;\n    const fieldsAreSame = fields_1.Fields.equals(selfFields, otherFields);\n    return nameIsSame && discriminantIsSame && fieldsAreSame;\n  }\n\n  getFields() {\n    return this.fields;\n  }\n\n  valueOf() {\n    let result = {\n      name: this.name,\n      fields: []\n    };\n    this.fields.forEach(field => result.fields[field.name] = field.value.valueOf());\n    return result;\n  }\n\n}\n\nexports.EnumValue = EnumValue;","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/enum.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EnumValue = exports.EnumVariantDefinition = exports.EnumType = void 0;\nconst utils_1 = require(\"../../utils\");\nconst fields_1 = require(\"./fields\");\nconst types_1 = require(\"./types\");\nconst SimpleEnumMaxDiscriminant = 256;\nclass EnumType extends types_1.CustomType {\n    constructor(name, variants) {\n        super(name);\n        this.variants = [];\n        this.variants = variants;\n    }\n    static fromJSON(json) {\n        let variants = (json.variants || []).map((variant) => EnumVariantDefinition.fromJSON(variant));\n        return new EnumType(json.name, variants);\n    }\n    getVariantByDiscriminant(discriminant) {\n        let result = this.variants.find((e) => e.discriminant == discriminant);\n        utils_1.guardValueIsSet(`variant by discriminant (${discriminant})`, result);\n        return result;\n    }\n    getVariantByName(name) {\n        let result = this.variants.find((e) => e.name == name);\n        utils_1.guardValueIsSet(`variant by name (${name})`, result);\n        return result;\n    }\n}\nexports.EnumType = EnumType;\nclass EnumVariantDefinition {\n    constructor(name, discriminant, fieldsDefinitions = []) {\n        this.fieldsDefinitions = [];\n        utils_1.guardTrue(discriminant < SimpleEnumMaxDiscriminant, `discriminant for simple enum should be less than ${SimpleEnumMaxDiscriminant}`);\n        this.name = name;\n        this.discriminant = discriminant;\n        this.fieldsDefinitions = fieldsDefinitions;\n    }\n    static fromJSON(json) {\n        let definitions = (json.fields || []).map((definition) => fields_1.FieldDefinition.fromJSON(definition));\n        return new EnumVariantDefinition(json.name, json.discriminant, definitions);\n    }\n    getFieldsDefinitions() {\n        return this.fieldsDefinitions;\n    }\n}\nexports.EnumVariantDefinition = EnumVariantDefinition;\nclass EnumValue extends types_1.TypedValue {\n    constructor(type, variant, fields) {\n        super(type);\n        this.fields = [];\n        this.name = variant.name;\n        this.discriminant = variant.discriminant;\n        this.fields = fields;\n        let definitions = variant.getFieldsDefinitions();\n        fields_1.Fields.checkTyping(this.fields, definitions);\n    }\n    /**\n     * Utility (named constructor) to create a simple (i.e. without fields) enum value.\n     */\n    static fromName(type, name) {\n        let variant = type.getVariantByName(name);\n        return new EnumValue(type, variant, []);\n    }\n    /**\n     * Utility (named constructor) to create a simple (i.e. without fields) enum value.\n     */\n    static fromDiscriminant(type, discriminant) {\n        let variant = type.getVariantByDiscriminant(discriminant);\n        return new EnumValue(type, variant, []);\n    }\n    equals(other) {\n        if (!this.getType().equals(other.getType())) {\n            return false;\n        }\n        let selfFields = this.getFields();\n        let otherFields = other.getFields();\n        const nameIsSame = this.name == other.name;\n        const discriminantIsSame = this.discriminant == other.discriminant;\n        const fieldsAreSame = fields_1.Fields.equals(selfFields, otherFields);\n        return nameIsSame && discriminantIsSame && fieldsAreSame;\n    }\n    getFields() {\n        return this.fields;\n    }\n    valueOf() {\n        let result = { name: this.name, fields: [] };\n        this.fields.forEach((field) => (result.fields[field.name] = field.value.valueOf()));\n        return result;\n    }\n}\nexports.EnumValue = EnumValue;\n//# sourceMappingURL=enum.js.map"]},"metadata":{},"sourceType":"script"}