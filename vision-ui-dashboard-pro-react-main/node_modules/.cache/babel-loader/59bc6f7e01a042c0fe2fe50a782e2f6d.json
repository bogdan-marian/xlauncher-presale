{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionEventTopic = exports.TransactionEvent = exports.TransactionLogs = void 0;\n\nconst _1 = require(\".\");\n\nconst errors_1 = require(\"./errors\");\n\nclass TransactionLogs {\n  constructor(address, events) {\n    this.address = address;\n    this.events = events;\n  }\n\n  static empty() {\n    return new TransactionLogs(new _1.Address(), []);\n  }\n\n  static fromHttpResponse(logs) {\n    let address = new _1.Address(logs.address);\n    let events = (logs.events || []).map(event => TransactionEvent.fromHttpResponse(event));\n    return new TransactionLogs(address, events);\n  }\n\n  findEventByIdentifier(identifier) {\n    let event = this.events.filter(event => event.identifier == identifier)[0];\n\n    if (event) {\n      return event;\n    }\n\n    throw new errors_1.ErrTransactionEventNotFound(identifier);\n  }\n\n}\n\nexports.TransactionLogs = TransactionLogs;\n\nclass TransactionEvent {\n  constructor(address, identifier, topics) {\n    this.address = address;\n    this.identifier = identifier;\n    this.topics = topics;\n  }\n\n  static fromHttpResponse(responsePart) {\n    let topics = (responsePart.topics || []).map(topic => new TransactionEventTopic(topic));\n    let address = new _1.Address(responsePart.address);\n    let identifier = responsePart.identifier || \"\";\n    let event = new TransactionEvent(address, identifier, topics);\n    return event;\n  }\n\n}\n\nexports.TransactionEvent = TransactionEvent;\n\nclass TransactionEventTopic {\n  constructor(topic) {\n    this.raw = Buffer.from(topic || \"\", \"base64\");\n  }\n\n  toString() {\n    return this.raw.toString(\"utf8\");\n  }\n\n  valueOf() {\n    return this.raw;\n  }\n\n}\n\nexports.TransactionEventTopic = TransactionEventTopic;","map":{"version":3,"sources":["../src/transactionLogs.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,EAAA,GAAA,OAAA,CAAA,GAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAEA,MAAa,eAAb,CAA4B;EAIxB,WAAA,CAAY,OAAZ,EAA8B,MAA9B,EAAwD;IACpD,KAAK,OAAL,GAAe,OAAf;IACA,KAAK,MAAL,GAAc,MAAd;EACH;;EAEW,OAAL,KAAK,GAAA;IACR,OAAO,IAAI,eAAJ,CAAoB,IAAI,EAAA,CAAA,OAAJ,EAApB,EAAmC,EAAnC,CAAP;EACH;;EAEsB,OAAhB,gBAAgB,CAAC,IAAD,EAAU;IAC7B,IAAI,OAAO,GAAG,IAAI,EAAA,CAAA,OAAJ,CAAY,IAAI,CAAC,OAAjB,CAAd;IACA,IAAI,MAAM,GAAG,CAAC,IAAI,CAAC,MAAL,IAAe,EAAhB,EAAoB,GAApB,CAAyB,KAAD,IAAgB,gBAAgB,CAAC,gBAAjB,CAAkC,KAAlC,CAAxC,CAAb;IACA,OAAO,IAAI,eAAJ,CAAoB,OAApB,EAA6B,MAA7B,CAAP;EACH;;EAED,qBAAqB,CAAC,UAAD,EAAmB;IACpC,IAAI,KAAK,GAAG,KAAK,MAAL,CAAY,MAAZ,CAAmB,KAAK,IAAI,KAAK,CAAC,UAAN,IAAoB,UAAhD,EAA4D,CAA5D,CAAZ;;IACA,IAAI,KAAJ,EAAW;MACP,OAAO,KAAP;IACH;;IAED,MAAM,IAAI,QAAA,CAAA,2BAAJ,CAAgC,UAAhC,CAAN;EACH;;AA1BuB;;AAA5B,OAAA,CAAA,eAAA,GAAA,eAAA;;AA6BA,MAAa,gBAAb,CAA6B;EAKzB,WAAA,CAAY,OAAZ,EAA8B,UAA9B,EAAkD,MAAlD,EAAiF;IAC7E,KAAK,OAAL,GAAe,OAAf;IACA,KAAK,UAAL,GAAkB,UAAlB;IACA,KAAK,MAAL,GAAc,MAAd;EACH;;EAEsB,OAAhB,gBAAgB,CAAC,YAAD,EAItB;IACG,IAAI,MAAM,GAAG,CAAC,YAAY,CAAC,MAAb,IAAuB,EAAxB,EAA4B,GAA5B,CAAgC,KAAK,IAAI,IAAI,qBAAJ,CAA0B,KAA1B,CAAzC,CAAb;IACA,IAAI,OAAO,GAAG,IAAI,EAAA,CAAA,OAAJ,CAAY,YAAY,CAAC,OAAzB,CAAd;IACA,IAAI,UAAU,GAAG,YAAY,CAAC,UAAb,IAA2B,EAA5C;IACA,IAAI,KAAK,GAAG,IAAI,gBAAJ,CAAqB,OAArB,EAA8B,UAA9B,EAA0C,MAA1C,CAAZ;IACA,OAAO,KAAP;EACH;;AArBwB;;AAA7B,OAAA,CAAA,gBAAA,GAAA,gBAAA;;AAwBA,MAAa,qBAAb,CAAkC;EAG9B,WAAA,CAAY,KAAZ,EAAyB;IACrB,KAAK,GAAL,GAAW,MAAM,CAAC,IAAP,CAAY,KAAK,IAAI,EAArB,EAAyB,QAAzB,CAAX;EACH;;EAED,QAAQ,GAAA;IACJ,OAAO,KAAK,GAAL,CAAS,QAAT,CAAkB,MAAlB,CAAP;EACH;;EAED,OAAO,GAAA;IACH,OAAO,KAAK,GAAZ;EACH;;AAb6B;;AAAlC,OAAA,CAAA,qBAAA,GAAA,qBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TransactionEventTopic = exports.TransactionEvent = exports.TransactionLogs = void 0;\nconst _1 = require(\".\");\nconst errors_1 = require(\"./errors\");\nclass TransactionLogs {\n    constructor(address, events) {\n        this.address = address;\n        this.events = events;\n    }\n    static empty() {\n        return new TransactionLogs(new _1.Address(), []);\n    }\n    static fromHttpResponse(logs) {\n        let address = new _1.Address(logs.address);\n        let events = (logs.events || []).map((event) => TransactionEvent.fromHttpResponse(event));\n        return new TransactionLogs(address, events);\n    }\n    findEventByIdentifier(identifier) {\n        let event = this.events.filter(event => event.identifier == identifier)[0];\n        if (event) {\n            return event;\n        }\n        throw new errors_1.ErrTransactionEventNotFound(identifier);\n    }\n}\nexports.TransactionLogs = TransactionLogs;\nclass TransactionEvent {\n    constructor(address, identifier, topics) {\n        this.address = address;\n        this.identifier = identifier;\n        this.topics = topics;\n    }\n    static fromHttpResponse(responsePart) {\n        let topics = (responsePart.topics || []).map(topic => new TransactionEventTopic(topic));\n        let address = new _1.Address(responsePart.address);\n        let identifier = responsePart.identifier || \"\";\n        let event = new TransactionEvent(address, identifier, topics);\n        return event;\n    }\n}\nexports.TransactionEvent = TransactionEvent;\nclass TransactionEventTopic {\n    constructor(topic) {\n        this.raw = Buffer.from(topic || \"\", \"base64\");\n    }\n    toString() {\n        return this.raw.toString(\"utf8\");\n    }\n    valueOf() {\n        return this.raw;\n    }\n}\nexports.TransactionEventTopic = TransactionEventTopic;\n//# sourceMappingURL=transactionLogs.js.map"]},"metadata":{},"sourceType":"script"}