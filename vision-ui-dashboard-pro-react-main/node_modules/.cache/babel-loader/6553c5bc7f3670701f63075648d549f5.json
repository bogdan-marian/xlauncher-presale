{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HWProvider = void 0;\n\nconst hw_transport_webusb_1 = __importDefault(require(\"@ledgerhq/hw-transport-webusb\"));\n\nconst hw_transport_webhid_1 = __importDefault(require(\"@ledgerhq/hw-transport-webhid\"));\n\nconst hw_transport_u2f_1 = __importDefault(require(\"@ledgerhq/hw-transport-u2f\")); // @ts-ignore\n\n\nconst hw_app_elrond_1 = __importDefault(require(\"@elrondnetwork/hw-app-elrond\"));\n\nconst platform_1 = __importDefault(require(\"platform\"));\n\nconst address_1 = require(\"../address\");\n\nconst signature_1 = require(\"../signature\");\n\nconst versioning_1 = require(\"../versioning\");\n\nconst constants_1 = require(\"./constants\");\n\nconst networkParams_1 = require(\"../networkParams\");\n\nclass HWProvider {\n  constructor(httpProvider) {\n    this.addressIndex = 0;\n    this.provider = httpProvider;\n  }\n  /**\n   * Creates transport and initialises ledger app.\n   */\n\n\n  init() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const transport = yield this.getTransport();\n        this.hwApp = new hw_app_elrond_1.default(transport);\n        return true;\n      } catch (error) {\n        return false;\n      }\n    });\n  }\n\n  getTransport() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let webUSBSupported = yield hw_transport_webusb_1.default.isSupported();\n      webUSBSupported = webUSBSupported && platform_1.default.name !== \"Opera\";\n\n      if (webUSBSupported) {\n        return yield hw_transport_webusb_1.default.create();\n      }\n\n      let webHIDSupported = yield hw_transport_webhid_1.default.isSupported();\n\n      if (webHIDSupported) {\n        return yield hw_transport_webhid_1.default.open(\"\");\n      }\n\n      return yield hw_transport_u2f_1.default.create();\n    });\n  }\n  /**\n   * Returns true if init() was previously called successfully\n   */\n\n\n  isInitialized() {\n    return !!this.hwApp;\n  }\n  /**\n   * Mocked function, returns isInitialized as an async function\n   */\n\n\n  isConnected() {\n    return new Promise((resolve, _) => resolve(this.isInitialized()));\n  }\n  /**\n   * Performs a login request by setting the selected index in Ledger and returning that address\n   */\n\n\n  login(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.hwApp) {\n        throw new Error(\"HWApp not initialised, call init() first\");\n      }\n\n      if (options && options.addressIndex) {\n        this.addressIndex = options.addressIndex;\n      }\n\n      yield this.hwApp.setAddress(0, this.addressIndex);\n      const {\n        address\n      } = yield this.hwApp.getAddress(0, this.addressIndex, true);\n      return address;\n    });\n  }\n\n  getAccounts() {\n    let page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let pageSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.hwApp) {\n        throw new Error(\"HWApp not initialised, call init() first\");\n      }\n\n      const addresses = [];\n      const startIndex = page * pageSize;\n\n      for (let index = startIndex; index < startIndex + pageSize; index++) {\n        const {\n          address\n        } = yield this.hwApp.getAddress(0, index);\n        addresses.push(address);\n      }\n\n      return addresses;\n    });\n  }\n  /**\n   * Mocks a logout request by returning true\n   */\n\n\n  logout() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.hwApp) {\n        throw new Error(\"HWApp not initialised, call init() first\");\n      }\n\n      return true;\n    });\n  }\n  /**\n   * Fetches current selected ledger address\n   */\n\n\n  getAddress() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.getCurrentAddress();\n    });\n  }\n  /**\n   * Signs and sends a transaction. Returns the transaction hash\n   * @param transaction\n   */\n\n\n  sendTransaction(transaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      transaction = yield this.signTransaction(transaction);\n      yield transaction.send(this.provider);\n      return transaction;\n    });\n  }\n\n  signTransaction(transaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.hwApp) {\n        throw new Error(\"HWApp not initialised, call init() first\");\n      }\n\n      const address = yield this.getCurrentAddress();\n      let signUsingHash = yield this.shouldSignUsingHash();\n\n      if (signUsingHash) {\n        transaction.options = networkParams_1.TransactionOptions.withTxHashSignOptions();\n        transaction.version = networkParams_1.TransactionVersion.withTxHashSignVersion();\n      }\n\n      const sig = yield this.hwApp.signTransaction(transaction.serializeForSigning(new address_1.Address(address)), signUsingHash);\n      transaction.applySignature(new signature_1.Signature(sig), new address_1.Address(address));\n      return transaction;\n    });\n  }\n\n  signTransactions(transactions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let retTx = [];\n\n      for (let tx of transactions) {\n        retTx.push(yield this.signTransaction(tx));\n      }\n\n      return retTx;\n    });\n  }\n\n  signMessage(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.hwApp) {\n        throw new Error(\"HWApp not initialised, call init() first\");\n      }\n\n      const signature = yield this.hwApp.signMessage(message.serializeForSigningRaw());\n      message.applySignature(new signature_1.Signature(signature));\n      return message;\n    });\n  }\n\n  tokenLogin(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.hwApp) {\n        throw new Error(\"HWApp not initialised, call init() first\");\n      }\n\n      if (options && options.addressIndex) {\n        this.addressIndex = options.addressIndex;\n      }\n\n      yield this.hwApp.setAddress(0, this.addressIndex);\n      const {\n        signature,\n        address\n      } = yield this.hwApp.getAddressAndSignAuthToken(0, this.addressIndex, options.token);\n      return {\n        signature: new signature_1.Signature(signature),\n        address\n      };\n    });\n  }\n\n  shouldSignUsingHash() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.hwApp) {\n        throw new Error(\"HWApp not initialised, call init() first\");\n      }\n\n      const config = yield this.hwApp.getAppConfiguration();\n      let diff = versioning_1.compareVersions(config.version, constants_1.LEDGER_TX_HASH_SIGN_MIN_VERSION);\n      return diff >= 0;\n    });\n  }\n\n  getCurrentAddress() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.hwApp) {\n        throw new Error(\"HWApp not initialised, call init() first\");\n      }\n\n      const {\n        address\n      } = yield this.hwApp.getAddress(0, this.addressIndex);\n      return address;\n    });\n  }\n\n}\n\nexports.HWProvider = HWProvider;","map":{"version":3,"sources":["../../src/dapp/hwProvider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HWProvider = void 0;\nconst hw_transport_webusb_1 = __importDefault(require(\"@ledgerhq/hw-transport-webusb\"));\nconst hw_transport_webhid_1 = __importDefault(require(\"@ledgerhq/hw-transport-webhid\"));\nconst hw_transport_u2f_1 = __importDefault(require(\"@ledgerhq/hw-transport-u2f\"));\n// @ts-ignore\nconst hw_app_elrond_1 = __importDefault(require(\"@elrondnetwork/hw-app-elrond\"));\nconst platform_1 = __importDefault(require(\"platform\"));\nconst address_1 = require(\"../address\");\nconst signature_1 = require(\"../signature\");\nconst versioning_1 = require(\"../versioning\");\nconst constants_1 = require(\"./constants\");\nconst networkParams_1 = require(\"../networkParams\");\nclass HWProvider {\n    constructor(httpProvider) {\n        this.addressIndex = 0;\n        this.provider = httpProvider;\n    }\n    /**\n     * Creates transport and initialises ledger app.\n     */\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const transport = yield this.getTransport();\n                this.hwApp = new hw_app_elrond_1.default(transport);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        });\n    }\n    getTransport() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let webUSBSupported = yield hw_transport_webusb_1.default.isSupported();\n            webUSBSupported =\n                webUSBSupported &&\n                    platform_1.default.name !== \"Opera\";\n            if (webUSBSupported) {\n                return yield hw_transport_webusb_1.default.create();\n            }\n            let webHIDSupported = yield hw_transport_webhid_1.default.isSupported();\n            if (webHIDSupported) {\n                return yield hw_transport_webhid_1.default.open(\"\");\n            }\n            return yield hw_transport_u2f_1.default.create();\n        });\n    }\n    /**\n     * Returns true if init() was previously called successfully\n     */\n    isInitialized() {\n        return !!this.hwApp;\n    }\n    /**\n     * Mocked function, returns isInitialized as an async function\n     */\n    isConnected() {\n        return new Promise((resolve, _) => resolve(this.isInitialized()));\n    }\n    /**\n     * Performs a login request by setting the selected index in Ledger and returning that address\n     */\n    login(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.hwApp) {\n                throw new Error(\"HWApp not initialised, call init() first\");\n            }\n            if (options && options.addressIndex) {\n                this.addressIndex = options.addressIndex;\n            }\n            yield this.hwApp.setAddress(0, this.addressIndex);\n            const { address } = yield this.hwApp.getAddress(0, this.addressIndex, true);\n            return address;\n        });\n    }\n    getAccounts(page = 0, pageSize = 10) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.hwApp) {\n                throw new Error(\"HWApp not initialised, call init() first\");\n            }\n            const addresses = [];\n            const startIndex = page * pageSize;\n            for (let index = startIndex; index < startIndex + pageSize; index++) {\n                const { address } = yield this.hwApp.getAddress(0, index);\n                addresses.push(address);\n            }\n            return addresses;\n        });\n    }\n    /**\n     * Mocks a logout request by returning true\n     */\n    logout() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.hwApp) {\n                throw new Error(\"HWApp not initialised, call init() first\");\n            }\n            return true;\n        });\n    }\n    /**\n     * Fetches current selected ledger address\n     */\n    getAddress() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.getCurrentAddress();\n        });\n    }\n    /**\n     * Signs and sends a transaction. Returns the transaction hash\n     * @param transaction\n     */\n    sendTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            transaction = yield this.signTransaction(transaction);\n            yield transaction.send(this.provider);\n            return transaction;\n        });\n    }\n    signTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.hwApp) {\n                throw new Error(\"HWApp not initialised, call init() first\");\n            }\n            const address = yield this.getCurrentAddress();\n            let signUsingHash = yield this.shouldSignUsingHash();\n            if (signUsingHash) {\n                transaction.options = networkParams_1.TransactionOptions.withTxHashSignOptions();\n                transaction.version = networkParams_1.TransactionVersion.withTxHashSignVersion();\n            }\n            const sig = yield this.hwApp.signTransaction(transaction.serializeForSigning(new address_1.Address(address)), signUsingHash);\n            transaction.applySignature(new signature_1.Signature(sig), new address_1.Address(address));\n            return transaction;\n        });\n    }\n    signTransactions(transactions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let retTx = [];\n            for (let tx of transactions) {\n                retTx.push(yield this.signTransaction(tx));\n            }\n            return retTx;\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.hwApp) {\n                throw new Error(\"HWApp not initialised, call init() first\");\n            }\n            const signature = yield this.hwApp.signMessage(message.serializeForSigningRaw());\n            message.applySignature(new signature_1.Signature(signature));\n            return message;\n        });\n    }\n    tokenLogin(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.hwApp) {\n                throw new Error(\"HWApp not initialised, call init() first\");\n            }\n            if (options && options.addressIndex) {\n                this.addressIndex = options.addressIndex;\n            }\n            yield this.hwApp.setAddress(0, this.addressIndex);\n            const { signature, address } = yield this.hwApp.getAddressAndSignAuthToken(0, this.addressIndex, options.token);\n            return {\n                signature: new signature_1.Signature(signature),\n                address\n            };\n        });\n    }\n    shouldSignUsingHash() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.hwApp) {\n                throw new Error(\"HWApp not initialised, call init() first\");\n            }\n            const config = yield this.hwApp.getAppConfiguration();\n            let diff = versioning_1.compareVersions(config.version, constants_1.LEDGER_TX_HASH_SIGN_MIN_VERSION);\n            return diff >= 0;\n        });\n    }\n    getCurrentAddress() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.hwApp) {\n                throw new Error(\"HWApp not initialised, call init() first\");\n            }\n            const { address } = yield this.hwApp.getAddress(0, this.addressIndex);\n            return address;\n        });\n    }\n}\nexports.HWProvider = HWProvider;\n//# sourceMappingURL=hwProvider.js.map"]},"metadata":{},"sourceType":"script"}