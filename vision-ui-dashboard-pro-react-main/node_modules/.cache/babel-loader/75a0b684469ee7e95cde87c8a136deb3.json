{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ContractWrapper = void 0;\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst fs_1 = __importDefault(require(\"fs\"));\n\nconst __1 = require(\"..\");\n\nconst chainSendContext_1 = require(\"./chainSendContext\");\n\nconst generateMethods_1 = require(\"./generateMethods\");\n\nconst formattedCall_1 = require(\"./formattedCall\");\n\nconst argumentErrorContext_1 = require(\"../argumentErrorContext\");\n\nconst __2 = require(\"../..\");\n\nconst preparedCall_1 = require(\"./preparedCall\");\n\nconst _1 = require(\".\");\n\nconst testutils_1 = require(\"../../testutils\");\n/**\n * Provides a simple interface in order to easily call or query the smart contract's methods.\n */\n\n\nclass ContractWrapper extends chainSendContext_1.ChainSendContext {\n  constructor(smartContract, abi, wasmPath, context, builtinFunctions) {\n    super(context);\n    this.context = context;\n    this.smartContract = smartContract;\n    this.abi = abi;\n    this.wasmPath = wasmPath;\n    this.builtinFunctions = builtinFunctions || this;\n    this.call = generateMethods_1.generateMethods(this, this.abi, this.handleCall);\n    this.results = generateMethods_1.generateMethods(this, this.abi, this.handleResults);\n    this.query = generateMethods_1.generateMethods(this, this.abi, this.handleQuery);\n    this.format = generateMethods_1.generateMethods(this, this.abi, this.handleFormat);\n    let constructor = this.abi.getConstructorDefinition();\n\n    if (constructor !== null) {\n      this.call.deploy = this.handleDeployCall.bind(this, constructor);\n      this.format.deploy = this.handleFormat.bind(this, constructor);\n    }\n  }\n\n  address(address) {\n    let typedAddress = __1.NativeSerializer.convertNativeToAddress(address, new argumentErrorContext_1.ArgumentErrorContext(\"address\", \"0\", new __1.EndpointParameterDefinition(\"address\", \"\", new __1.AddressType())));\n\n    this.smartContract.setAddress(typedAddress);\n    return this;\n  }\n\n  getAddress() {\n    return this.smartContract.getAddress();\n  }\n\n  getAbi() {\n    return this.abi;\n  }\n\n  getSmartContract() {\n    return this.smartContract;\n  }\n\n  getCode() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.wasmPath == null) {\n        throw new __2.Err(\"contract wasm path not configured\");\n      }\n\n      return yield testutils_1.loadContractCode(this.wasmPath);\n    });\n  }\n\n  buildDeployTransaction(constructorDefinition, args) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let contractCode = yield this.getCode();\n      let convertedArgs = formattedCall_1.formatEndpoint(constructorDefinition, constructorDefinition, ...args).toTypedValues();\n      let transaction = this.smartContract.deploy({\n        code: contractCode,\n        gasLimit: this.context.getGasLimit(),\n        initArguments: convertedArgs\n      });\n      return transaction;\n    });\n  }\n\n  handleDeployCall(constructorDefinition) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return __awaiter(this, void 0, void 0, function* () {\n      let transaction = yield this.buildDeployTransaction(constructorDefinition, args);\n      let transactionOnNetwork = yield this.processTransaction(transaction);\n      let smartContractResults = transactionOnNetwork.getSmartContractResults();\n      let immediateResult = smartContractResults.getImmediate();\n      immediateResult.assertSuccess();\n      let logger = this.context.getLogger();\n      logger === null || logger === void 0 ? void 0 : logger.deployComplete(transaction, smartContractResults, this.smartContract.getAddress());\n    });\n  }\n\n  static loadProject(provider, builtinFunctions, projectPath, filenameHint, sendContext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let {\n        abiPath,\n        wasmPath\n      } = yield expandProjectPath(projectPath, filenameHint);\n      let abi = yield __1.SmartContractAbi.fromAbiPath(abiPath);\n      let smartContract = new __1.SmartContract({\n        abi: abi\n      });\n      sendContext = sendContext || new _1.SendContext(provider).logger(new _1.ContractLogger());\n      return new ContractWrapper(smartContract, abi, wasmPath, sendContext, builtinFunctions);\n    });\n  }\n\n  handleQuery(endpoint) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    return __awaiter(this, void 0, void 0, function* () {\n      let preparedCall = yield this.prepareCallWithPayment(endpoint, args);\n      let interaction = this.convertPreparedCallToInteraction(preparedCall);\n      let provider = this.context.getProvider();\n      let logger = this.context.getLogger();\n      let query = interaction.buildQuery();\n      logger === null || logger === void 0 ? void 0 : logger.queryCreated(query);\n      let optionalSender = this.context.getSenderOptional();\n\n      if (optionalSender != null) {\n        query.caller = optionalSender.address;\n      }\n\n      let response = yield provider.queryContract(query);\n      console.log(\"got response...\", response);\n      let queryResponseBundle = interaction.interpretQueryResponse(response);\n      let result = queryResponseBundle.queryResponse.unpackOutput();\n      logger === null || logger === void 0 ? void 0 : logger.queryComplete(result, response);\n      return result;\n    });\n  }\n\n  handleCall(endpoint) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n\n    return __awaiter(this, void 0, void 0, function* () {\n      let {\n        transaction,\n        interaction\n      } = this.buildTransactionAndInteraction(endpoint, args);\n      let {\n        result\n      } = yield this.processTransactionAndInterpretResults({\n        transaction,\n        interaction\n      });\n      return result;\n    });\n  }\n\n  handleResults(endpoint) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n\n    return __awaiter(this, void 0, void 0, function* () {\n      let {\n        transaction,\n        interaction\n      } = this.buildTransactionAndInteraction(endpoint, args);\n      let {\n        executionResultsBundle\n      } = yield this.processTransactionAndInterpretResults({\n        transaction,\n        interaction\n      });\n      return executionResultsBundle;\n    });\n  }\n\n  processTransactionAndInterpretResults(_ref) {\n    let {\n      transaction,\n      interaction\n    } = _ref;\n    return __awaiter(this, void 0, void 0, function* () {\n      let transactionOnNetwork = yield this.processTransaction(transaction);\n      let executionResultsBundle = interaction.interpretExecutionResults(transactionOnNetwork);\n      let {\n        smartContractResults,\n        immediateResult\n      } = executionResultsBundle;\n      let result = immediateResult === null || immediateResult === void 0 ? void 0 : immediateResult.unpackOutput();\n      let logger = this.context.getLogger();\n      logger === null || logger === void 0 ? void 0 : logger.transactionComplete(result, immediateResult === null || immediateResult === void 0 ? void 0 : immediateResult.data, transaction, smartContractResults);\n      return {\n        executionResultsBundle,\n        result\n      };\n    });\n  }\n\n  processTransaction(transaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let provider = this.context.getProvider();\n      let sender = this.context.getSender();\n      transaction.setNonce(sender.account.nonce);\n      yield sender.signer.sign(transaction);\n      let logger = this.context.getLogger();\n      logger === null || logger === void 0 ? void 0 : logger.transactionCreated(transaction);\n      yield transaction.send(provider); // increment the nonce only after the transaction is sent\n      // since an exception thrown by the provider means we will have to re-use the same nonce\n      // otherwise the next transactions will hang (and never complete)\n\n      sender.account.incrementNonce();\n      logger === null || logger === void 0 ? void 0 : logger.transactionSent(transaction);\n      yield transaction.awaitExecuted(provider);\n      let transactionOnNetwork = yield transaction.getAsOnNetwork(provider, true, false, true);\n\n      if (transaction.getStatus().isFailed()) {\n        // TODO: extract the error messages\n        //let results = transactionOnNetwork.getSmartContractResults().getAllResults();\n        //let messages = results.map((result) => console.log(result));\n        throw new __2.ErrContract(`Transaction status failed: [${transaction.getStatus().toString()}].`); // Return messages:\\n${messages}`);\n      }\n\n      return transactionOnNetwork;\n    });\n  }\n\n  handleFormat(endpoint) {\n    for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      args[_key5 - 1] = arguments[_key5];\n    }\n\n    let {\n      formattedCall\n    } = this.prepareCallWithPayment(endpoint, args);\n    return formattedCall;\n  }\n\n  buildTransactionAndInteraction(endpoint, args) {\n    let preparedCall = this.prepareCallWithPayment(endpoint, args);\n    let interaction = this.convertPreparedCallToInteraction(preparedCall);\n    interaction.withGasLimit(this.context.getGasLimit());\n    let transaction = interaction.buildTransaction();\n    return {\n      transaction,\n      interaction\n    };\n  }\n\n  prepareCallWithPayment(endpoint, args) {\n    let value = this.context.getAndResetValue();\n\n    if (value == null && endpoint.modifiers.isPayable()) {\n      throw new __2.Err(\"Did not provide any value for a payable method\");\n    }\n\n    if (value != null && !endpoint.modifiers.isPayable()) {\n      throw new __2.Err(\"A value was provided for a non-payable method\");\n    }\n\n    if (value != null && !endpoint.modifiers.isPayableInToken(value.token.getTokenIdentifier())) {\n      throw new __2.Err(`Token ${value.token.getTokenIdentifier()} is not accepted by payable method. Accepted tokens: ${endpoint.modifiers.payableInTokens}`);\n    }\n\n    let formattedCall = formattedCall_1.formatEndpoint(endpoint, endpoint, ...args);\n    let preparedCall = new preparedCall_1.PreparedCall(this.smartContract.getAddress(), __2.Egld(0), formattedCall);\n    this.applyValueModfiers(value, preparedCall);\n    return preparedCall;\n  }\n\n  convertPreparedCallToInteraction(preparedCall) {\n    let executingFunction = preparedCall.formattedCall.getExecutingFunction();\n    let interpretingFunction = preparedCall.formattedCall.getInterpretingFunction();\n    let typedValueArgs = preparedCall.formattedCall.toTypedValues();\n    let interaction = new __1.Interaction(this.smartContract, executingFunction, interpretingFunction, typedValueArgs, preparedCall.receiver);\n    interaction.withValue(preparedCall.egldValue);\n    return interaction;\n  }\n\n  applyValueModfiers(value, preparedCall) {\n    if (value == null) {\n      return;\n    }\n\n    if (value.token.isEgld()) {\n      preparedCall.egldValue = value;\n      return;\n    }\n\n    if (value.token.isFungible()) {\n      preparedCall.wrap(this.builtinFunctions.format.ESDTTransfer(value.token.getTokenIdentifier(), value.valueOf(), preparedCall.formattedCall));\n    } else {\n      preparedCall.receiver = this.context.getSender().address;\n      preparedCall.wrap(this.builtinFunctions.format.ESDTNFTTransfer(value.token.getTokenIdentifier(), value.getNonce(), value.valueOf(), this.smartContract, preparedCall.formattedCall));\n    }\n  }\n\n}\n\nexports.ContractWrapper = ContractWrapper;\n\nfunction filterByExtension(fileList, extension) {\n  return fileList.filter(name => name.endsWith(extension));\n}\n\nfunction filterByFilename(fileList, filename) {\n  return fileList.filter(name => name == filename);\n} // Compiling creates a temporary file which sometimes doesn't get deleted. It should be ignored.\n\n\nfunction ignoreTemporaryWasmFiles(fileList) {\n  let temporaryWasmFiles = filterByExtension(fileList, \"_wasm.wasm\");\n  let difference = fileList.filter(file => temporaryWasmFiles.indexOf(file) === -1);\n  return difference;\n}\n\nfunction filterWithHint(fileList, extension, filenameHint) {\n  if (filenameHint) {\n    let pattern = filenameHint + extension;\n    return {\n      pattern,\n      filteredFileList: filterByFilename(fileList, pattern)\n    };\n  }\n\n  return {\n    pattern: \"*\" + extension,\n    filteredFileList: filterByExtension(fileList, extension)\n  };\n}\n\nfunction getFileByExtension(fileList, folderPath, extension, filenameHint) {\n  let {\n    pattern,\n    filteredFileList\n  } = filterWithHint(fileList, extension, filenameHint);\n\n  if (filteredFileList.length != 1) {\n    throw new __2.ErrInvalidArgument(`Expected a single ${pattern} file in ${folderPath} (found ${filteredFileList.length})`);\n  }\n\n  return path_1.default.join(folderPath, filteredFileList[0]);\n}\n\nfunction getAbiAndWasmPaths(outputPath, filenameHint) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let filesInOutput = yield fs_1.default.promises.readdir(outputPath);\n    filesInOutput = ignoreTemporaryWasmFiles(filesInOutput);\n    let abiPath = getFileByExtension(filesInOutput, outputPath, \".abi.json\", filenameHint);\n    let wasmPath;\n\n    try {\n      wasmPath = getFileByExtension(filesInOutput, outputPath, \".wasm\", filenameHint);\n    } catch (_) {\n      wasmPath = null;\n    }\n\n    return {\n      abiPath,\n      wasmPath\n    };\n  });\n}\n\nfunction expandProjectPath(projectPath, filenameHint) {\n  return __awaiter(this, void 0, void 0, function* () {\n    projectPath = path_1.default.resolve(projectPath);\n\n    try {\n      return yield getAbiAndWasmPaths(projectPath, filenameHint);\n    } catch (_) {\n      let outputPath = path_1.default.join(projectPath, \"output\");\n      return yield getAbiAndWasmPaths(outputPath, filenameHint);\n    }\n  });\n}","map":{"version":3,"sources":["../../../src/smartcontracts/wrapper/contractWrapper.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContractWrapper = void 0;\nconst path_1 = __importDefault(require(\"path\"));\nconst fs_1 = __importDefault(require(\"fs\"));\nconst __1 = require(\"..\");\nconst chainSendContext_1 = require(\"./chainSendContext\");\nconst generateMethods_1 = require(\"./generateMethods\");\nconst formattedCall_1 = require(\"./formattedCall\");\nconst argumentErrorContext_1 = require(\"../argumentErrorContext\");\nconst __2 = require(\"../..\");\nconst preparedCall_1 = require(\"./preparedCall\");\nconst _1 = require(\".\");\nconst testutils_1 = require(\"../../testutils\");\n/**\n * Provides a simple interface in order to easily call or query the smart contract's methods.\n */\nclass ContractWrapper extends chainSendContext_1.ChainSendContext {\n    constructor(smartContract, abi, wasmPath, context, builtinFunctions) {\n        super(context);\n        this.context = context;\n        this.smartContract = smartContract;\n        this.abi = abi;\n        this.wasmPath = wasmPath;\n        this.builtinFunctions = builtinFunctions || this;\n        this.call = generateMethods_1.generateMethods(this, this.abi, this.handleCall);\n        this.results = generateMethods_1.generateMethods(this, this.abi, this.handleResults);\n        this.query = generateMethods_1.generateMethods(this, this.abi, this.handleQuery);\n        this.format = generateMethods_1.generateMethods(this, this.abi, this.handleFormat);\n        let constructor = this.abi.getConstructorDefinition();\n        if (constructor !== null) {\n            this.call.deploy = this.handleDeployCall.bind(this, constructor);\n            this.format.deploy = this.handleFormat.bind(this, constructor);\n        }\n    }\n    address(address) {\n        let typedAddress = __1.NativeSerializer.convertNativeToAddress(address, new argumentErrorContext_1.ArgumentErrorContext(\"address\", \"0\", new __1.EndpointParameterDefinition(\"address\", \"\", new __1.AddressType())));\n        this.smartContract.setAddress(typedAddress);\n        return this;\n    }\n    getAddress() {\n        return this.smartContract.getAddress();\n    }\n    getAbi() {\n        return this.abi;\n    }\n    getSmartContract() {\n        return this.smartContract;\n    }\n    getCode() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.wasmPath == null) {\n                throw new __2.Err(\"contract wasm path not configured\");\n            }\n            return yield testutils_1.loadContractCode(this.wasmPath);\n        });\n    }\n    buildDeployTransaction(constructorDefinition, args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let contractCode = yield this.getCode();\n            let convertedArgs = formattedCall_1.formatEndpoint(constructorDefinition, constructorDefinition, ...args).toTypedValues();\n            let transaction = this.smartContract.deploy({\n                code: contractCode,\n                gasLimit: this.context.getGasLimit(),\n                initArguments: convertedArgs\n            });\n            return transaction;\n        });\n    }\n    handleDeployCall(constructorDefinition, ...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let transaction = yield this.buildDeployTransaction(constructorDefinition, args);\n            let transactionOnNetwork = yield this.processTransaction(transaction);\n            let smartContractResults = transactionOnNetwork.getSmartContractResults();\n            let immediateResult = smartContractResults.getImmediate();\n            immediateResult.assertSuccess();\n            let logger = this.context.getLogger();\n            logger === null || logger === void 0 ? void 0 : logger.deployComplete(transaction, smartContractResults, this.smartContract.getAddress());\n        });\n    }\n    static loadProject(provider, builtinFunctions, projectPath, filenameHint, sendContext) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let { abiPath, wasmPath } = yield expandProjectPath(projectPath, filenameHint);\n            let abi = yield __1.SmartContractAbi.fromAbiPath(abiPath);\n            let smartContract = new __1.SmartContract({ abi: abi });\n            sendContext = sendContext || new _1.SendContext(provider).logger(new _1.ContractLogger());\n            return new ContractWrapper(smartContract, abi, wasmPath, sendContext, builtinFunctions);\n        });\n    }\n    handleQuery(endpoint, ...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let preparedCall = yield this.prepareCallWithPayment(endpoint, args);\n            let interaction = this.convertPreparedCallToInteraction(preparedCall);\n            let provider = this.context.getProvider();\n            let logger = this.context.getLogger();\n            let query = interaction.buildQuery();\n            logger === null || logger === void 0 ? void 0 : logger.queryCreated(query);\n            let optionalSender = this.context.getSenderOptional();\n            if (optionalSender != null) {\n                query.caller = optionalSender.address;\n            }\n            let response = yield provider.queryContract(query);\n            console.log(\"got response...\", response);\n            let queryResponseBundle = interaction.interpretQueryResponse(response);\n            let result = queryResponseBundle.queryResponse.unpackOutput();\n            logger === null || logger === void 0 ? void 0 : logger.queryComplete(result, response);\n            return result;\n        });\n    }\n    handleCall(endpoint, ...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let { transaction, interaction } = this.buildTransactionAndInteraction(endpoint, args);\n            let { result } = yield this.processTransactionAndInterpretResults({ transaction, interaction });\n            return result;\n        });\n    }\n    handleResults(endpoint, ...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let { transaction, interaction } = this.buildTransactionAndInteraction(endpoint, args);\n            let { executionResultsBundle } = yield this.processTransactionAndInterpretResults({ transaction, interaction });\n            return executionResultsBundle;\n        });\n    }\n    processTransactionAndInterpretResults({ transaction, interaction }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let transactionOnNetwork = yield this.processTransaction(transaction);\n            let executionResultsBundle = interaction.interpretExecutionResults(transactionOnNetwork);\n            let { smartContractResults, immediateResult } = executionResultsBundle;\n            let result = immediateResult === null || immediateResult === void 0 ? void 0 : immediateResult.unpackOutput();\n            let logger = this.context.getLogger();\n            logger === null || logger === void 0 ? void 0 : logger.transactionComplete(result, immediateResult === null || immediateResult === void 0 ? void 0 : immediateResult.data, transaction, smartContractResults);\n            return { executionResultsBundle, result };\n        });\n    }\n    processTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let provider = this.context.getProvider();\n            let sender = this.context.getSender();\n            transaction.setNonce(sender.account.nonce);\n            yield sender.signer.sign(transaction);\n            let logger = this.context.getLogger();\n            logger === null || logger === void 0 ? void 0 : logger.transactionCreated(transaction);\n            yield transaction.send(provider);\n            // increment the nonce only after the transaction is sent\n            // since an exception thrown by the provider means we will have to re-use the same nonce\n            // otherwise the next transactions will hang (and never complete)\n            sender.account.incrementNonce();\n            logger === null || logger === void 0 ? void 0 : logger.transactionSent(transaction);\n            yield transaction.awaitExecuted(provider);\n            let transactionOnNetwork = yield transaction.getAsOnNetwork(provider, true, false, true);\n            if (transaction.getStatus().isFailed()) {\n                // TODO: extract the error messages\n                //let results = transactionOnNetwork.getSmartContractResults().getAllResults();\n                //let messages = results.map((result) => console.log(result));\n                throw new __2.ErrContract(`Transaction status failed: [${transaction.getStatus().toString()}].`); // Return messages:\\n${messages}`);\n            }\n            return transactionOnNetwork;\n        });\n    }\n    handleFormat(endpoint, ...args) {\n        let { formattedCall } = this.prepareCallWithPayment(endpoint, args);\n        return formattedCall;\n    }\n    buildTransactionAndInteraction(endpoint, args) {\n        let preparedCall = this.prepareCallWithPayment(endpoint, args);\n        let interaction = this.convertPreparedCallToInteraction(preparedCall);\n        interaction.withGasLimit(this.context.getGasLimit());\n        let transaction = interaction.buildTransaction();\n        return { transaction, interaction };\n    }\n    prepareCallWithPayment(endpoint, args) {\n        let value = this.context.getAndResetValue();\n        if (value == null && endpoint.modifiers.isPayable()) {\n            throw new __2.Err(\"Did not provide any value for a payable method\");\n        }\n        if (value != null && !endpoint.modifiers.isPayable()) {\n            throw new __2.Err(\"A value was provided for a non-payable method\");\n        }\n        if (value != null && !endpoint.modifiers.isPayableInToken(value.token.getTokenIdentifier())) {\n            throw new __2.Err(`Token ${value.token.getTokenIdentifier()} is not accepted by payable method. Accepted tokens: ${endpoint.modifiers.payableInTokens}`);\n        }\n        let formattedCall = formattedCall_1.formatEndpoint(endpoint, endpoint, ...args);\n        let preparedCall = new preparedCall_1.PreparedCall(this.smartContract.getAddress(), __2.Egld(0), formattedCall);\n        this.applyValueModfiers(value, preparedCall);\n        return preparedCall;\n    }\n    convertPreparedCallToInteraction(preparedCall) {\n        let executingFunction = preparedCall.formattedCall.getExecutingFunction();\n        let interpretingFunction = preparedCall.formattedCall.getInterpretingFunction();\n        let typedValueArgs = preparedCall.formattedCall.toTypedValues();\n        let interaction = new __1.Interaction(this.smartContract, executingFunction, interpretingFunction, typedValueArgs, preparedCall.receiver);\n        interaction.withValue(preparedCall.egldValue);\n        return interaction;\n    }\n    applyValueModfiers(value, preparedCall) {\n        if (value == null) {\n            return;\n        }\n        if (value.token.isEgld()) {\n            preparedCall.egldValue = value;\n            return;\n        }\n        if (value.token.isFungible()) {\n            preparedCall.wrap(this.builtinFunctions.format.ESDTTransfer(value.token.getTokenIdentifier(), value.valueOf(), preparedCall.formattedCall));\n        }\n        else {\n            preparedCall.receiver = this.context.getSender().address;\n            preparedCall.wrap(this.builtinFunctions.format.ESDTNFTTransfer(value.token.getTokenIdentifier(), value.getNonce(), value.valueOf(), this.smartContract, preparedCall.formattedCall));\n        }\n    }\n}\nexports.ContractWrapper = ContractWrapper;\nfunction filterByExtension(fileList, extension) {\n    return fileList.filter(name => name.endsWith(extension));\n}\nfunction filterByFilename(fileList, filename) {\n    return fileList.filter(name => name == filename);\n}\n// Compiling creates a temporary file which sometimes doesn't get deleted. It should be ignored.\nfunction ignoreTemporaryWasmFiles(fileList) {\n    let temporaryWasmFiles = filterByExtension(fileList, \"_wasm.wasm\");\n    let difference = fileList.filter(file => temporaryWasmFiles.indexOf(file) === -1);\n    return difference;\n}\nfunction filterWithHint(fileList, extension, filenameHint) {\n    if (filenameHint) {\n        let pattern = filenameHint + extension;\n        return {\n            pattern,\n            filteredFileList: filterByFilename(fileList, pattern)\n        };\n    }\n    return {\n        pattern: \"*\" + extension,\n        filteredFileList: filterByExtension(fileList, extension)\n    };\n}\nfunction getFileByExtension(fileList, folderPath, extension, filenameHint) {\n    let { pattern, filteredFileList } = filterWithHint(fileList, extension, filenameHint);\n    if (filteredFileList.length != 1) {\n        throw new __2.ErrInvalidArgument(`Expected a single ${pattern} file in ${folderPath} (found ${filteredFileList.length})`);\n    }\n    return path_1.default.join(folderPath, filteredFileList[0]);\n}\nfunction getAbiAndWasmPaths(outputPath, filenameHint) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let filesInOutput = yield fs_1.default.promises.readdir(outputPath);\n        filesInOutput = ignoreTemporaryWasmFiles(filesInOutput);\n        let abiPath = getFileByExtension(filesInOutput, outputPath, \".abi.json\", filenameHint);\n        let wasmPath;\n        try {\n            wasmPath = getFileByExtension(filesInOutput, outputPath, \".wasm\", filenameHint);\n        }\n        catch (_) {\n            wasmPath = null;\n        }\n        return { abiPath, wasmPath };\n    });\n}\nfunction expandProjectPath(projectPath, filenameHint) {\n    return __awaiter(this, void 0, void 0, function* () {\n        projectPath = path_1.default.resolve(projectPath);\n        try {\n            return yield getAbiAndWasmPaths(projectPath, filenameHint);\n        }\n        catch (_) {\n            let outputPath = path_1.default.join(projectPath, \"output\");\n            return yield getAbiAndWasmPaths(outputPath, filenameHint);\n        }\n    });\n}\n//# sourceMappingURL=contractWrapper.js.map"]},"metadata":{},"sourceType":"script"}