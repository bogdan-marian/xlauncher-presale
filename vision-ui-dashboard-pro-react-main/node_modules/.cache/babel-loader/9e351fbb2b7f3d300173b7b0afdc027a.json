{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArgSerializer = exports.ArgumentsSeparator = void 0;\n\nvar codec_1 = require(\"./codec\");\n\nvar composite_1 = require(\"./typesystem/composite\");\n\nvar variadic_1 = require(\"./typesystem/variadic\");\n\nvar algebraic_1 = require(\"./typesystem/algebraic\");\n\nexports.ArgumentsSeparator = \"@\";\n/**\n * For the moment, this is the only codec used.\n */\n\nvar Codec = new codec_1.BinaryCodec();\n\nvar ArgSerializer = /*#__PURE__*/function () {\n  function ArgSerializer() {\n    _classCallCheck(this, ArgSerializer);\n  }\n\n  _createClass(ArgSerializer, [{\n    key: \"stringToValues\",\n    value:\n    /**\n     * Reads typed values from an arguments string (e.g. aa@bb@@cc), given parameter definitions.\n     */\n    function stringToValues(joinedString, parameters) {\n      var buffers = this.stringToBuffers(joinedString);\n      var values = this.buffersToValues(buffers, parameters);\n      return values;\n    }\n    /**\n     * Reads raw buffers from an arguments string (e.g. aa@bb@@cc).\n     */\n\n  }, {\n    key: \"stringToBuffers\",\n    value: function stringToBuffers(joinedString) {\n      // We also keep the zero-length buffers (they could encode missing options, Option<T>).\n      return joinedString.split(exports.ArgumentsSeparator).map(function (item) {\n        return Buffer.from(item, \"hex\");\n      });\n    }\n    /**\n     * Decodes a set of buffers into a set of typed values, given parameter definitions.\n     */\n\n  }, {\n    key: \"buffersToValues\",\n    value: function buffersToValues(buffers, parameters) {\n      // TODO: Refactor, split (function is quite complex).\n      buffers = buffers || [];\n      var values = [];\n      var bufferIndex = 0;\n      var numBuffers = buffers.length;\n\n      for (var i = 0; i < parameters.length; i++) {\n        var parameter = parameters[i];\n        var type = parameter.type;\n        var value = readValue(type);\n        values.push(value);\n      } // This is a recursive function.\n\n\n      function readValue(type) {\n        // TODO: Use matchers.\n        if (type instanceof algebraic_1.OptionalType) {\n          var typedValue = readValue(type.getFirstTypeParameter());\n          return new algebraic_1.OptionalValue(type, typedValue);\n        } else if (type instanceof variadic_1.VariadicType) {\n          var typedValues = [];\n\n          while (!hasReachedTheEnd()) {\n            typedValues.push(readValue(type.getFirstTypeParameter()));\n          }\n\n          return new variadic_1.VariadicValue(type, typedValues);\n        } else if (type instanceof composite_1.CompositeType) {\n          var _typedValues = [];\n\n          var _iterator = _createForOfIteratorHelper(type.getTypeParameters()),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var typeParameter = _step.value;\n\n              _typedValues.push(readValue(typeParameter));\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          return new composite_1.CompositeValue(type, _typedValues);\n        } else {\n          // Non-composite (singular), non-variadic (fixed) type.\n          // The only branching without a recursive call.\n          var _typedValue = decodeNextBuffer(type);\n\n          return _typedValue;\n        }\n      }\n\n      function decodeNextBuffer(type) {\n        if (hasReachedTheEnd()) {\n          return null;\n        }\n\n        var buffer = buffers[bufferIndex++];\n        var decodedValue = Codec.decodeTopLevel(buffer, type);\n        return decodedValue;\n      }\n\n      function hasReachedTheEnd() {\n        return bufferIndex >= numBuffers;\n      }\n\n      return values;\n    }\n    /**\n     * Serializes a set of typed values into an arguments string (e.g. aa@bb@@cc).\n     */\n\n  }, {\n    key: \"valuesToString\",\n    value: function valuesToString(values) {\n      var strings = this.valuesToStrings(values);\n      var argumentsString = strings.join(exports.ArgumentsSeparator);\n      var count = strings.length;\n      return {\n        argumentsString: argumentsString,\n        count: count\n      };\n    }\n    /**\n     * Serializes a set of typed values into a set of strings.\n     */\n\n  }, {\n    key: \"valuesToStrings\",\n    value: function valuesToStrings(values) {\n      var buffers = this.valuesToBuffers(values);\n      var strings = buffers.map(function (buffer) {\n        return buffer.toString(\"hex\");\n      });\n      return strings;\n    }\n    /**\n     * Serializes a set of typed values into a set of strings buffers.\n     * Variadic types and composite types might result into none, one or more buffers.\n     */\n\n  }, {\n    key: \"valuesToBuffers\",\n    value: function valuesToBuffers(values) {\n      // TODO: Refactor, split (function is quite complex).\n      var buffers = [];\n\n      var _iterator2 = _createForOfIteratorHelper(values),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var value = _step2.value;\n          handleValue(value);\n        } // This is a recursive function. It appends to the \"buffers\" variable.\n\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      function handleValue(value) {\n        // TODO: Use matchers.\n        if (value instanceof algebraic_1.OptionalValue) {\n          if (value.isSet()) {\n            handleValue(value.getTypedValue());\n          }\n        } else if (value instanceof variadic_1.VariadicValue) {\n          var _iterator3 = _createForOfIteratorHelper(value.getItems()),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var item = _step3.value;\n              handleValue(item);\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        } else if (value instanceof composite_1.CompositeValue) {\n          var _iterator4 = _createForOfIteratorHelper(value.getItems()),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _item = _step4.value;\n              handleValue(_item);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        } else {\n          // Non-composite (singular), non-variadic (fixed) type.\n          // The only branching without a recursive call.\n          var buffer = Codec.encodeTopLevel(value);\n          buffers.push(buffer);\n        }\n      }\n\n      return buffers;\n    }\n  }]);\n\n  return ArgSerializer;\n}();\n\nexports.ArgSerializer = ArgSerializer;","map":{"version":3,"sources":["../../src/smartcontracts/argSerializer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ArgSerializer = exports.ArgumentsSeparator = void 0;\nconst codec_1 = require(\"./codec\");\nconst composite_1 = require(\"./typesystem/composite\");\nconst variadic_1 = require(\"./typesystem/variadic\");\nconst algebraic_1 = require(\"./typesystem/algebraic\");\nexports.ArgumentsSeparator = \"@\";\n/**\n * For the moment, this is the only codec used.\n */\nconst Codec = new codec_1.BinaryCodec();\nclass ArgSerializer {\n    /**\n     * Reads typed values from an arguments string (e.g. aa@bb@@cc), given parameter definitions.\n     */\n    stringToValues(joinedString, parameters) {\n        let buffers = this.stringToBuffers(joinedString);\n        let values = this.buffersToValues(buffers, parameters);\n        return values;\n    }\n    /**\n     * Reads raw buffers from an arguments string (e.g. aa@bb@@cc).\n     */\n    stringToBuffers(joinedString) {\n        // We also keep the zero-length buffers (they could encode missing options, Option<T>).\n        return joinedString.split(exports.ArgumentsSeparator).map(item => Buffer.from(item, \"hex\"));\n    }\n    /**\n     * Decodes a set of buffers into a set of typed values, given parameter definitions.\n     */\n    buffersToValues(buffers, parameters) {\n        // TODO: Refactor, split (function is quite complex).\n        buffers = buffers || [];\n        let values = [];\n        let bufferIndex = 0;\n        let numBuffers = buffers.length;\n        for (let i = 0; i < parameters.length; i++) {\n            let parameter = parameters[i];\n            let type = parameter.type;\n            let value = readValue(type);\n            values.push(value);\n        }\n        // This is a recursive function.\n        function readValue(type) {\n            // TODO: Use matchers.\n            if (type instanceof algebraic_1.OptionalType) {\n                let typedValue = readValue(type.getFirstTypeParameter());\n                return new algebraic_1.OptionalValue(type, typedValue);\n            }\n            else if (type instanceof variadic_1.VariadicType) {\n                let typedValues = [];\n                while (!hasReachedTheEnd()) {\n                    typedValues.push(readValue(type.getFirstTypeParameter()));\n                }\n                return new variadic_1.VariadicValue(type, typedValues);\n            }\n            else if (type instanceof composite_1.CompositeType) {\n                let typedValues = [];\n                for (const typeParameter of type.getTypeParameters()) {\n                    typedValues.push(readValue(typeParameter));\n                }\n                return new composite_1.CompositeValue(type, typedValues);\n            }\n            else {\n                // Non-composite (singular), non-variadic (fixed) type.\n                // The only branching without a recursive call.\n                let typedValue = decodeNextBuffer(type);\n                return typedValue;\n            }\n        }\n        function decodeNextBuffer(type) {\n            if (hasReachedTheEnd()) {\n                return null;\n            }\n            let buffer = buffers[bufferIndex++];\n            let decodedValue = Codec.decodeTopLevel(buffer, type);\n            return decodedValue;\n        }\n        function hasReachedTheEnd() {\n            return bufferIndex >= numBuffers;\n        }\n        return values;\n    }\n    /**\n     * Serializes a set of typed values into an arguments string (e.g. aa@bb@@cc).\n     */\n    valuesToString(values) {\n        let strings = this.valuesToStrings(values);\n        let argumentsString = strings.join(exports.ArgumentsSeparator);\n        let count = strings.length;\n        return { argumentsString, count };\n    }\n    /**\n     * Serializes a set of typed values into a set of strings.\n     */\n    valuesToStrings(values) {\n        let buffers = this.valuesToBuffers(values);\n        let strings = buffers.map(buffer => buffer.toString(\"hex\"));\n        return strings;\n    }\n    /**\n     * Serializes a set of typed values into a set of strings buffers.\n     * Variadic types and composite types might result into none, one or more buffers.\n     */\n    valuesToBuffers(values) {\n        // TODO: Refactor, split (function is quite complex).\n        let buffers = [];\n        for (const value of values) {\n            handleValue(value);\n        }\n        // This is a recursive function. It appends to the \"buffers\" variable.\n        function handleValue(value) {\n            // TODO: Use matchers.\n            if (value instanceof algebraic_1.OptionalValue) {\n                if (value.isSet()) {\n                    handleValue(value.getTypedValue());\n                }\n            }\n            else if (value instanceof variadic_1.VariadicValue) {\n                for (const item of value.getItems()) {\n                    handleValue(item);\n                }\n            }\n            else if (value instanceof composite_1.CompositeValue) {\n                for (const item of value.getItems()) {\n                    handleValue(item);\n                }\n            }\n            else {\n                // Non-composite (singular), non-variadic (fixed) type.\n                // The only branching without a recursive call.\n                let buffer = Codec.encodeTopLevel(value);\n                buffers.push(buffer);\n            }\n        }\n        return buffers;\n    }\n}\nexports.ArgSerializer = ArgSerializer;\n//# sourceMappingURL=argSerializer.js.map"]},"metadata":{},"sourceType":"script"}