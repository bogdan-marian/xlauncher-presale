{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _regeneratorRuntime = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/regenerator/index.js\");\n\nvar _classCallCheck = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbiRegistry = void 0;\n\nvar fs = __importStar(require(\"fs\"));\n\nvar errors = __importStar(require(\"../../errors\"));\n\nvar axios_1 = __importDefault(require(\"axios\"));\n\nvar utils_1 = require(\"../../utils\");\n\nvar struct_1 = require(\"./struct\");\n\nvar contractInterface_1 = require(\"./contractInterface\");\n\nvar enum_1 = require(\"./enum\");\n\nvar typeMapper_1 = require(\"./typeMapper\");\n\nvar endpoint_1 = require(\"./endpoint\");\n\nvar AbiRegistry = /*#__PURE__*/function () {\n  function AbiRegistry() {\n    _classCallCheck(this, AbiRegistry);\n\n    this.interfaces = [];\n    this.customTypes = [];\n  }\n  /**\n   * Convenience factory function to load ABIs (from files or URLs).\n   * This function will also remap ABI types to know types (on best-efforts basis).\n   */\n\n\n  _createClass(AbiRegistry, [{\n    key: \"extendFromFile\",\n    value:\n    /**\n     * Generally, one should use {@link AbiRegistry.load} instead.\n     */\n    function extendFromFile(file) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var jsonContent, json;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return fs.promises.readFile(file, {\n                  encoding: \"utf8\"\n                });\n\n              case 2:\n                jsonContent = _context.sent;\n                json = JSON.parse(jsonContent);\n                return _context.abrupt(\"return\", this.extend(json));\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Generally, one should use {@link AbiRegistry.load} instead.\n     */\n\n  }, {\n    key: \"extendFromUrl\",\n    value: function extendFromUrl(url) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var response, json;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return axios_1.default.get(url);\n\n              case 2:\n                response = _context2.sent;\n                json = response.data;\n                return _context2.abrupt(\"return\", this.extend(json));\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n  }, {\n    key: \"extend\",\n    value: function extend(json) {\n      json.types = json.types || {}; // The \"endpoints\" collection is interpreted by \"ContractInterface\".\n\n      var iface = contractInterface_1.ContractInterface.fromJSON(json);\n      this.interfaces.push(iface);\n\n      for (var customTypeName in json.types) {\n        var itemJson = json.types[customTypeName];\n        var typeDiscriminant = itemJson.type; // Workaround: set the \"name\" field, as required by \"fromJSON()\" below.\n\n        itemJson.name = customTypeName;\n        var customType = this.createCustomType(typeDiscriminant, itemJson);\n        this.customTypes.push(customType);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"createCustomType\",\n    value: function createCustomType(typeDiscriminant, json) {\n      if (typeDiscriminant == \"struct\") {\n        return struct_1.StructType.fromJSON(json);\n      }\n\n      if (typeDiscriminant == \"enum\") {\n        return enum_1.EnumType.fromJSON(json);\n      }\n\n      throw new errors.ErrTypingSystem(\"Unknown type discriminant: \".concat(typeDiscriminant));\n    }\n  }, {\n    key: \"getInterface\",\n    value: function getInterface(name) {\n      var result = this.interfaces.find(function (e) {\n        return e.name == name;\n      });\n      utils_1.guardValueIsSetWithMessage(\"interface [\".concat(name, \"] not found\"), result);\n      return result;\n    }\n  }, {\n    key: \"getInterfaces\",\n    value: function getInterfaces(names) {\n      var _this = this;\n\n      return names.map(function (name) {\n        return _this.getInterface(name);\n      });\n    }\n  }, {\n    key: \"getStruct\",\n    value: function getStruct(name) {\n      var result = this.customTypes.find(function (e) {\n        return e.getName() == name && e instanceof struct_1.StructType;\n      });\n      utils_1.guardValueIsSetWithMessage(\"struct [\".concat(name, \"] not found\"), result);\n      return result;\n    }\n  }, {\n    key: \"getStructs\",\n    value: function getStructs(names) {\n      var _this2 = this;\n\n      return names.map(function (name) {\n        return _this2.getStruct(name);\n      });\n    }\n  }, {\n    key: \"getEnum\",\n    value: function getEnum(name) {\n      var result = this.customTypes.find(function (e) {\n        return e.getName() == name && e instanceof enum_1.EnumType;\n      });\n      utils_1.guardValueIsSetWithMessage(\"enum [\".concat(name, \"] not found\"), result);\n      return result;\n    }\n  }, {\n    key: \"getEnums\",\n    value: function getEnums(names) {\n      var _this3 = this;\n\n      return names.map(function (name) {\n        return _this3.getEnum(name);\n      });\n    }\n    /**\n     * Right after loading ABI definitions into a registry (e.g. from a file), the endpoints and the custom types (structs, enums)\n     * use raw types for their I/O parameters (in the case of endpoints), or for their fields (in the case of structs).\n     *\n     * A raw type is merely an instance of {@link Type}, with a given name and type parameters (if it's a generic type).\n     *\n     * Though, for most (development) purposes, we'd like to operate using known, specific types (e.g. {@link List}, {@link U8Type} etc.).\n     * This function increases the specificity of the types used by parameter / field definitions within a registry (on best-efforts basis).\n     * The result is an equivalent, more explicit ABI registry.\n     */\n\n  }, {\n    key: \"remapToKnownTypes\",\n    value: function remapToKnownTypes() {\n      var _newRegistry$customTy, _newRegistry$interfac;\n\n      var mapper = new typeMapper_1.TypeMapper(this.customTypes);\n      var newCustomTypes = [];\n      var newInterfaces = []; // First, remap custom types (actually, under the hood, this will remap types of struct fields)\n\n      var _iterator = _createForOfIteratorHelper(this.customTypes),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var type = _step.value;\n          var mappedTyped = mapper.mapType(type);\n          newCustomTypes.push(mappedTyped);\n          mapper.feedCustomType(mappedTyped);\n        } // Then, remap types of all endpoint parameters.\n        // But we'll use an enhanced mapper, that takes into account the results from the previous step.\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      mapper = new typeMapper_1.TypeMapper(newCustomTypes);\n\n      var _iterator2 = _createForOfIteratorHelper(this.interfaces),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var iface = _step2.value;\n          var newEndpoints = [];\n\n          var _iterator3 = _createForOfIteratorHelper(iface.endpoints),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var endpoint = _step3.value;\n              newEndpoints.push(mapEndpoint(endpoint, mapper));\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n\n          var newConstructor = iface.constructorDefinition ? mapEndpoint(iface.constructorDefinition, mapper) : null;\n          newInterfaces.push(new contractInterface_1.ContractInterface(iface.name, newConstructor, newEndpoints));\n        } // Now return the new registry, with all types remapped to known types\n\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var newRegistry = new AbiRegistry();\n\n      (_newRegistry$customTy = newRegistry.customTypes).push.apply(_newRegistry$customTy, newCustomTypes);\n\n      (_newRegistry$interfac = newRegistry.interfaces).push.apply(_newRegistry$interfac, newInterfaces);\n\n      return newRegistry;\n    }\n  }], [{\n    key: \"load\",\n    value: function load(json) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var registry, _iterator4, _step4, file, _iterator5, _step5, url;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                registry = new AbiRegistry();\n                _iterator4 = _createForOfIteratorHelper(json.files || []);\n                _context3.prev = 2;\n\n                _iterator4.s();\n\n              case 4:\n                if ((_step4 = _iterator4.n()).done) {\n                  _context3.next = 10;\n                  break;\n                }\n\n                file = _step4.value;\n                _context3.next = 8;\n                return registry.extendFromFile(file);\n\n              case 8:\n                _context3.next = 4;\n                break;\n\n              case 10:\n                _context3.next = 15;\n                break;\n\n              case 12:\n                _context3.prev = 12;\n                _context3.t0 = _context3[\"catch\"](2);\n\n                _iterator4.e(_context3.t0);\n\n              case 15:\n                _context3.prev = 15;\n\n                _iterator4.f();\n\n                return _context3.finish(15);\n\n              case 18:\n                _iterator5 = _createForOfIteratorHelper(json.urls || []);\n                _context3.prev = 19;\n\n                _iterator5.s();\n\n              case 21:\n                if ((_step5 = _iterator5.n()).done) {\n                  _context3.next = 27;\n                  break;\n                }\n\n                url = _step5.value;\n                _context3.next = 25;\n                return registry.extendFromUrl(url);\n\n              case 25:\n                _context3.next = 21;\n                break;\n\n              case 27:\n                _context3.next = 32;\n                break;\n\n              case 29:\n                _context3.prev = 29;\n                _context3.t1 = _context3[\"catch\"](19);\n\n                _iterator5.e(_context3.t1);\n\n              case 32:\n                _context3.prev = 32;\n\n                _iterator5.f();\n\n                return _context3.finish(32);\n\n              case 35:\n                registry = registry.remapToKnownTypes();\n                return _context3.abrupt(\"return\", registry);\n\n              case 37:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, null, [[2, 12, 15, 18], [19, 29, 32, 35]]);\n      }));\n    }\n  }]);\n\n  return AbiRegistry;\n}();\n\nexports.AbiRegistry = AbiRegistry;\n\nfunction mapEndpoint(endpoint, mapper) {\n  var newInput = endpoint.input.map(function (e) {\n    return new endpoint_1.EndpointParameterDefinition(e.name, e.description, mapper.mapType(e.type));\n  });\n  var newOutput = endpoint.output.map(function (e) {\n    return new endpoint_1.EndpointParameterDefinition(e.name, e.description, mapper.mapType(e.type));\n  });\n  return new endpoint_1.EndpointDefinition(endpoint.name, newInput, newOutput, endpoint.modifiers);\n}","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/abiRegistry.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbiRegistry = void 0;\nconst fs = __importStar(require(\"fs\"));\nconst errors = __importStar(require(\"../../errors\"));\nconst axios_1 = __importDefault(require(\"axios\"));\nconst utils_1 = require(\"../../utils\");\nconst struct_1 = require(\"./struct\");\nconst contractInterface_1 = require(\"./contractInterface\");\nconst enum_1 = require(\"./enum\");\nconst typeMapper_1 = require(\"./typeMapper\");\nconst endpoint_1 = require(\"./endpoint\");\nclass AbiRegistry {\n    constructor() {\n        this.interfaces = [];\n        this.customTypes = [];\n    }\n    /**\n     * Convenience factory function to load ABIs (from files or URLs).\n     * This function will also remap ABI types to know types (on best-efforts basis).\n     */\n    static load(json) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let registry = new AbiRegistry();\n            for (const file of json.files || []) {\n                yield registry.extendFromFile(file);\n            }\n            for (const url of json.urls || []) {\n                yield registry.extendFromUrl(url);\n            }\n            registry = registry.remapToKnownTypes();\n            return registry;\n        });\n    }\n    /**\n     * Generally, one should use {@link AbiRegistry.load} instead.\n     */\n    extendFromFile(file) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let jsonContent = yield fs.promises.readFile(file, { encoding: \"utf8\" });\n            let json = JSON.parse(jsonContent);\n            return this.extend(json);\n        });\n    }\n    /**\n     * Generally, one should use {@link AbiRegistry.load} instead.\n     */\n    extendFromUrl(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let response = yield axios_1.default.get(url);\n            let json = response.data;\n            return this.extend(json);\n        });\n    }\n    extend(json) {\n        json.types = json.types || {};\n        // The \"endpoints\" collection is interpreted by \"ContractInterface\".\n        let iface = contractInterface_1.ContractInterface.fromJSON(json);\n        this.interfaces.push(iface);\n        for (const customTypeName in json.types) {\n            let itemJson = json.types[customTypeName];\n            let typeDiscriminant = itemJson.type;\n            // Workaround: set the \"name\" field, as required by \"fromJSON()\" below.\n            itemJson.name = customTypeName;\n            let customType = this.createCustomType(typeDiscriminant, itemJson);\n            this.customTypes.push(customType);\n        }\n        return this;\n    }\n    createCustomType(typeDiscriminant, json) {\n        if (typeDiscriminant == \"struct\") {\n            return struct_1.StructType.fromJSON(json);\n        }\n        if (typeDiscriminant == \"enum\") {\n            return enum_1.EnumType.fromJSON(json);\n        }\n        throw new errors.ErrTypingSystem(`Unknown type discriminant: ${typeDiscriminant}`);\n    }\n    getInterface(name) {\n        let result = this.interfaces.find((e) => e.name == name);\n        utils_1.guardValueIsSetWithMessage(`interface [${name}] not found`, result);\n        return result;\n    }\n    getInterfaces(names) {\n        return names.map((name) => this.getInterface(name));\n    }\n    getStruct(name) {\n        let result = this.customTypes.find((e) => e.getName() == name && e instanceof struct_1.StructType);\n        utils_1.guardValueIsSetWithMessage(`struct [${name}] not found`, result);\n        return result;\n    }\n    getStructs(names) {\n        return names.map((name) => this.getStruct(name));\n    }\n    getEnum(name) {\n        let result = this.customTypes.find((e) => e.getName() == name && e instanceof enum_1.EnumType);\n        utils_1.guardValueIsSetWithMessage(`enum [${name}] not found`, result);\n        return result;\n    }\n    getEnums(names) {\n        return names.map((name) => this.getEnum(name));\n    }\n    /**\n     * Right after loading ABI definitions into a registry (e.g. from a file), the endpoints and the custom types (structs, enums)\n     * use raw types for their I/O parameters (in the case of endpoints), or for their fields (in the case of structs).\n     *\n     * A raw type is merely an instance of {@link Type}, with a given name and type parameters (if it's a generic type).\n     *\n     * Though, for most (development) purposes, we'd like to operate using known, specific types (e.g. {@link List}, {@link U8Type} etc.).\n     * This function increases the specificity of the types used by parameter / field definitions within a registry (on best-efforts basis).\n     * The result is an equivalent, more explicit ABI registry.\n     */\n    remapToKnownTypes() {\n        let mapper = new typeMapper_1.TypeMapper(this.customTypes);\n        let newCustomTypes = [];\n        let newInterfaces = [];\n        // First, remap custom types (actually, under the hood, this will remap types of struct fields)\n        for (const type of this.customTypes) {\n            const mappedTyped = mapper.mapType(type);\n            newCustomTypes.push(mappedTyped);\n            mapper.feedCustomType(mappedTyped);\n        }\n        // Then, remap types of all endpoint parameters.\n        // But we'll use an enhanced mapper, that takes into account the results from the previous step.\n        mapper = new typeMapper_1.TypeMapper(newCustomTypes);\n        for (const iface of this.interfaces) {\n            let newEndpoints = [];\n            for (const endpoint of iface.endpoints) {\n                newEndpoints.push(mapEndpoint(endpoint, mapper));\n            }\n            let newConstructor = iface.constructorDefinition ? mapEndpoint(iface.constructorDefinition, mapper) : null;\n            newInterfaces.push(new contractInterface_1.ContractInterface(iface.name, newConstructor, newEndpoints));\n        }\n        // Now return the new registry, with all types remapped to known types\n        let newRegistry = new AbiRegistry();\n        newRegistry.customTypes.push(...newCustomTypes);\n        newRegistry.interfaces.push(...newInterfaces);\n        return newRegistry;\n    }\n}\nexports.AbiRegistry = AbiRegistry;\nfunction mapEndpoint(endpoint, mapper) {\n    let newInput = endpoint.input.map((e) => new endpoint_1.EndpointParameterDefinition(e.name, e.description, mapper.mapType(e.type)));\n    let newOutput = endpoint.output.map((e) => new endpoint_1.EndpointParameterDefinition(e.name, e.description, mapper.mapType(e.type)));\n    return new endpoint_1.EndpointDefinition(endpoint.name, newInput, newOutput, endpoint.modifiers);\n}\n//# sourceMappingURL=abiRegistry.js.map"]},"metadata":{},"sourceType":"script"}