{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArgumentErrorContext = void 0;\n\nconst __1 = require(\"..\");\n\nclass ArgumentErrorContext {\n  constructor(endpointName, argumentIndex, parameterDefinition) {\n    this.endpointName = endpointName;\n    this.argumentIndex = argumentIndex;\n    this.parameterDefinition = parameterDefinition;\n  }\n\n  throwError(specificError) {\n    throw new __1.ErrInvalidArgument(`Error when converting arguments for endpoint (endpoint name: ${this.endpointName}, argument index: ${this.argumentIndex}, name: ${this.parameterDefinition.name}, type: ${this.parameterDefinition.type})\\nNested error: ${specificError}`);\n  }\n\n  convertError(native, typeName) {\n    this.throwError(`Can't convert argument (argument: ${native}, type ${typeof native}), wanted type: ${typeName})`);\n  }\n\n  unhandledType(functionName, type) {\n    this.throwError(`Unhandled type (function: ${functionName}, type: ${type})`);\n  }\n\n  guardSameLength(native, valueTypes) {\n    native = native || [];\n\n    if (native.length != valueTypes.length) {\n      this.throwError(`Incorrect composite type length: have ${native.length}, expected ${valueTypes.length} (argument: ${native})`);\n    }\n  }\n\n  guardHasField(native, fieldName) {\n    native = native || {};\n\n    if (!(fieldName in native)) {\n      this.throwError(`Struct argument does not contain a field named \"${fieldName}\" (argument: ${JSON.stringify(native)})`);\n    }\n  }\n\n}\n\nexports.ArgumentErrorContext = ArgumentErrorContext;","map":{"version":3,"sources":["../../src/smartcontracts/argumentErrorContext.ts"],"names":[],"mappings":";;;;;;;AACA,MAAA,GAAA,GAAA,OAAA,CAAA,IAAA,CAAA;;AAEA,MAAa,oBAAb,CAAiC;EAK7B,WAAA,CAAY,YAAZ,EAAkC,aAAlC,EAAyD,mBAAzD,EAAyG;IACrG,KAAK,YAAL,GAAoB,YAApB;IACA,KAAK,aAAL,GAAqB,aAArB;IACA,KAAK,mBAAL,GAA2B,mBAA3B;EACH;;EAED,UAAU,CAAC,aAAD,EAAsB;IAC5B,MAAM,IAAI,GAAA,CAAA,kBAAJ,CAAuB,gEAAgE,KAAK,YAAY,qBAAqB,KAAK,aAAa,WAAW,KAAK,mBAAL,CAAyB,IAAI,WAAW,KAAK,mBAAL,CAAyB,IAAI,oBAAoB,aAAa,EAAhQ,CAAN;EACH;;EAED,YAAY,CAAC,MAAD,EAAc,QAAd,EAA8B;IACtC,KAAK,UAAL,CAAgB,qCAAqC,MAAM,UAAU,OAAO,MAAM,mBAAmB,QAAQ,GAA7G;EACH;;EAED,aAAa,CAAC,YAAD,EAAuB,IAAvB,EAAiC;IAC1C,KAAK,UAAL,CAAgB,6BAA6B,YAAY,WAAW,IAAI,GAAxE;EACH;;EAED,eAAe,CAAI,MAAJ,EAAmB,UAAnB,EAAkC;IAC7C,MAAM,GAAG,MAAM,IAAI,EAAnB;;IACA,IAAI,MAAM,CAAC,MAAP,IAAiB,UAAU,CAAC,MAAhC,EAAwC;MACpC,KAAK,UAAL,CAAgB,yCAAyC,MAAM,CAAC,MAAM,cAAc,UAAU,CAAC,MAAM,eAAe,MAAM,GAA1H;IACH;EACJ;;EAED,aAAa,CAAC,MAAD,EAAc,SAAd,EAA+B;IACxC,MAAM,GAAG,MAAM,IAAI,EAAnB;;IACA,IAAI,EAAE,SAAS,IAAI,MAAf,CAAJ,EAA4B;MACxB,KAAK,UAAL,CAAgB,mDAAmD,SAAS,gBAAgB,IAAI,CAAC,SAAL,CAAe,MAAf,CAAsB,GAAlH;IACH;EACJ;;AAnC4B;;AAAjC,OAAA,CAAA,oBAAA,GAAA,oBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ArgumentErrorContext = void 0;\nconst __1 = require(\"..\");\nclass ArgumentErrorContext {\n    constructor(endpointName, argumentIndex, parameterDefinition) {\n        this.endpointName = endpointName;\n        this.argumentIndex = argumentIndex;\n        this.parameterDefinition = parameterDefinition;\n    }\n    throwError(specificError) {\n        throw new __1.ErrInvalidArgument(`Error when converting arguments for endpoint (endpoint name: ${this.endpointName}, argument index: ${this.argumentIndex}, name: ${this.parameterDefinition.name}, type: ${this.parameterDefinition.type})\\nNested error: ${specificError}`);\n    }\n    convertError(native, typeName) {\n        this.throwError(`Can't convert argument (argument: ${native}, type ${typeof native}), wanted type: ${typeName})`);\n    }\n    unhandledType(functionName, type) {\n        this.throwError(`Unhandled type (function: ${functionName}, type: ${type})`);\n    }\n    guardSameLength(native, valueTypes) {\n        native = native || [];\n        if (native.length != valueTypes.length) {\n            this.throwError(`Incorrect composite type length: have ${native.length}, expected ${valueTypes.length} (argument: ${native})`);\n        }\n    }\n    guardHasField(native, fieldName) {\n        native = native || {};\n        if (!(fieldName in native)) {\n            this.throwError(`Struct argument does not contain a field named \"${fieldName}\" (argument: ${JSON.stringify(native)})`);\n        }\n    }\n}\nexports.ArgumentErrorContext = ArgumentErrorContext;\n//# sourceMappingURL=argumentErrorContext.js.map"]},"metadata":{},"sourceType":"script"}