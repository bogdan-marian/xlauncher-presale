{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"/home/ionut/Desktop/xlauncher-presale/vision-ui-dashboard-pro-react-main/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Struct = exports.StructType = void 0;\n\nvar fields_1 = require(\"./fields\");\n\nvar types_1 = require(\"./types\");\n\nvar StructType = /*#__PURE__*/function (_types_1$CustomType) {\n  _inherits(StructType, _types_1$CustomType);\n\n  var _super = _createSuper(StructType);\n\n  function StructType(name, fieldsDefinitions) {\n    var _this;\n\n    _classCallCheck(this, StructType);\n\n    _this = _super.call(this, name);\n    _this.fieldsDefinitions = [];\n    _this.fieldsDefinitions = fieldsDefinitions;\n    return _this;\n  }\n\n  _createClass(StructType, [{\n    key: \"getFieldsDefinitions\",\n    value: function getFieldsDefinitions() {\n      return this.fieldsDefinitions;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      var definitions = (json.fields || []).map(function (definition) {\n        return fields_1.FieldDefinition.fromJSON(definition);\n      });\n      return new StructType(json.name, definitions);\n    }\n  }]);\n\n  return StructType;\n}(types_1.CustomType);\n\nexports.StructType = StructType; // TODO: implement setField(), convenience method.\n// TODO: Hold fields in a map (by name), and use the order within \"field definitions\" to perform codec operations.\n\nvar Struct = /*#__PURE__*/function (_types_1$TypedValue) {\n  _inherits(Struct, _types_1$TypedValue);\n\n  var _super2 = _createSuper(Struct);\n\n  /**\n   * Currently, one can only set fields at initialization time. Construction will be improved at a later time.\n   */\n  function Struct(type, fields) {\n    var _this2;\n\n    _classCallCheck(this, Struct);\n\n    _this2 = _super2.call(this, type);\n    _this2.fields = [];\n    _this2.fields = fields;\n\n    _this2.checkTyping();\n\n    return _this2;\n  }\n\n  _createClass(Struct, [{\n    key: \"checkTyping\",\n    value: function checkTyping() {\n      var type = this.getType();\n      var definitions = type.getFieldsDefinitions();\n      fields_1.Fields.checkTyping(this.fields, definitions);\n    }\n  }, {\n    key: \"getFields\",\n    value: function getFields() {\n      return this.fields;\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      var result = {};\n\n      var _iterator = _createForOfIteratorHelper(this.fields),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var field = _step.value;\n          result[field.name] = field.value.valueOf();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return result;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (!this.getType().equals(other.getType())) {\n        return false;\n      }\n\n      var selfFields = this.getFields();\n      var otherFields = other.getFields();\n      return fields_1.Fields.equals(selfFields, otherFields);\n    }\n  }]);\n\n  return Struct;\n}(types_1.TypedValue);\n\nexports.Struct = Struct;","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/struct.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,IAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;IAEa,U;;;;;EAGT,oBAAY,IAAZ,EAA0B,iBAA1B,EAA8D;IAAA;;IAAA;;IAC1D,0BAAM,IAAN;IAHa,MAAA,iBAAA,GAAuC,EAAvC;IAIb,MAAK,iBAAL,GAAyB,iBAAzB;IAF0D;EAG7D;;;;WAOD,gCAAoB;MAChB,OAAO,KAAK,iBAAZ;IACH;;;WAPD,kBAAgB,IAAhB,EAAqD;MACjD,IAAI,WAAW,GAAG,CAAC,IAAI,CAAC,MAAL,IAAe,EAAhB,EAAoB,GAApB,CAAwB,UAAA,UAAU;QAAA,OAAI,QAAA,CAAA,eAAA,CAAgB,QAAhB,CAAyB,UAAzB,CAAJ;MAAA,CAAlC,CAAlB;MACA,OAAO,IAAI,UAAJ,CAAe,IAAI,CAAC,IAApB,EAA0B,WAA1B,CAAP;IACH;;;;EAX2B,OAAA,CAAA,U;;AAAhC,OAAA,CAAA,UAAA,GAAA,UAAA,C,CAkBA;AACA;;IACa,M;;;;;EAGT;;AAEG;EACH,gBAAY,IAAZ,EAA8B,MAA9B,EAA6C;IAAA;;IAAA;;IACzC,4BAAM,IAAN;IANa,OAAA,MAAA,GAAkB,EAAlB;IAOb,OAAK,MAAL,GAAc,MAAd;;IAEA,OAAK,WAAL;;IAJyC;EAK5C;;;;WAEO,uBAAW;MACf,IAAI,IAAI,GAAe,KAAK,OAAL,EAAvB;MACA,IAAI,WAAW,GAAG,IAAI,CAAC,oBAAL,EAAlB;MACA,QAAA,CAAA,MAAA,CAAO,WAAP,CAAmB,KAAK,MAAxB,EAAgC,WAAhC;IACH;;;WAED,qBAAS;MACL,OAAO,KAAK,MAAZ;IACH;;;WAED,mBAAO;MACH,IAAI,MAAM,GAAQ,EAAlB;;MADG,2CAGiB,KAAK,MAHtB;MAAA;;MAAA;QAGH,oDAAiC;UAAA,IAAtB,KAAsB;UAC7B,MAAM,CAAC,KAAK,CAAC,IAAP,CAAN,GAAqB,KAAK,CAAC,KAAN,CAAY,OAAZ,EAArB;QACH;MALE;QAAA;MAAA;QAAA;MAAA;;MAOH,OAAO,MAAP;IACH;;;WAED,gBAAO,KAAP,EAAoB;MAChB,IAAI,CAAC,KAAK,OAAL,GAAe,MAAf,CAAsB,KAAK,CAAC,OAAN,EAAtB,CAAL,EAA6C;QACzC,OAAO,KAAP;MACH;;MAED,IAAI,UAAU,GAAG,KAAK,SAAL,EAAjB;MACA,IAAI,WAAW,GAAG,KAAK,CAAC,SAAN,EAAlB;MAEA,OAAO,QAAA,CAAA,MAAA,CAAO,MAAP,CAAc,UAAd,EAA0B,WAA1B,CAAP;IACH;;;;EA1CuB,OAAA,CAAA,U;;AAA5B,OAAA,CAAA,MAAA,GAAA,MAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Struct = exports.StructType = void 0;\nconst fields_1 = require(\"./fields\");\nconst types_1 = require(\"./types\");\nclass StructType extends types_1.CustomType {\n    constructor(name, fieldsDefinitions) {\n        super(name);\n        this.fieldsDefinitions = [];\n        this.fieldsDefinitions = fieldsDefinitions;\n    }\n    static fromJSON(json) {\n        let definitions = (json.fields || []).map(definition => fields_1.FieldDefinition.fromJSON(definition));\n        return new StructType(json.name, definitions);\n    }\n    getFieldsDefinitions() {\n        return this.fieldsDefinitions;\n    }\n}\nexports.StructType = StructType;\n// TODO: implement setField(), convenience method.\n// TODO: Hold fields in a map (by name), and use the order within \"field definitions\" to perform codec operations.\nclass Struct extends types_1.TypedValue {\n    /**\n     * Currently, one can only set fields at initialization time. Construction will be improved at a later time.\n     */\n    constructor(type, fields) {\n        super(type);\n        this.fields = [];\n        this.fields = fields;\n        this.checkTyping();\n    }\n    checkTyping() {\n        let type = this.getType();\n        let definitions = type.getFieldsDefinitions();\n        fields_1.Fields.checkTyping(this.fields, definitions);\n    }\n    getFields() {\n        return this.fields;\n    }\n    valueOf() {\n        let result = {};\n        for (const field of this.fields) {\n            result[field.name] = field.value.valueOf();\n        }\n        return result;\n    }\n    equals(other) {\n        if (!this.getType().equals(other.getType())) {\n            return false;\n        }\n        let selfFields = this.getFields();\n        let otherFields = other.getFields();\n        return fields_1.Fields.equals(selfFields, otherFields);\n    }\n}\nexports.Struct = Struct;\n//# sourceMappingURL=struct.js.map"]},"metadata":{},"sourceType":"script"}