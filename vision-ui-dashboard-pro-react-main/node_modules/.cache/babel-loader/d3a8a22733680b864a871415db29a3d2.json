{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArgSerializer = exports.ArgumentsSeparator = void 0;\n\nconst codec_1 = require(\"./codec\");\n\nconst composite_1 = require(\"./typesystem/composite\");\n\nconst variadic_1 = require(\"./typesystem/variadic\");\n\nconst algebraic_1 = require(\"./typesystem/algebraic\");\n\nexports.ArgumentsSeparator = \"@\";\n/**\n * For the moment, this is the only codec used.\n */\n\nconst Codec = new codec_1.BinaryCodec();\n\nclass ArgSerializer {\n  /**\n   * Reads typed values from an arguments string (e.g. aa@bb@@cc), given parameter definitions.\n   */\n  stringToValues(joinedString, parameters) {\n    let buffers = this.stringToBuffers(joinedString);\n    let values = this.buffersToValues(buffers, parameters);\n    return values;\n  }\n  /**\n   * Reads raw buffers from an arguments string (e.g. aa@bb@@cc).\n   */\n\n\n  stringToBuffers(joinedString) {\n    // We also keep the zero-length buffers (they could encode missing options, Option<T>).\n    return joinedString.split(exports.ArgumentsSeparator).map(item => Buffer.from(item, \"hex\"));\n  }\n  /**\n   * Decodes a set of buffers into a set of typed values, given parameter definitions.\n   */\n\n\n  buffersToValues(buffers, parameters) {\n    // TODO: Refactor, split (function is quite complex).\n    buffers = buffers || [];\n    let values = [];\n    let bufferIndex = 0;\n    let numBuffers = buffers.length;\n\n    for (let i = 0; i < parameters.length; i++) {\n      let parameter = parameters[i];\n      let type = parameter.type;\n      let value = readValue(type);\n      values.push(value);\n    } // This is a recursive function.\n\n\n    function readValue(type) {\n      // TODO: Use matchers.\n      if (type instanceof algebraic_1.OptionalType) {\n        let typedValue = readValue(type.getFirstTypeParameter());\n        return new algebraic_1.OptionalValue(type, typedValue);\n      } else if (type instanceof variadic_1.VariadicType) {\n        let typedValues = [];\n\n        while (!hasReachedTheEnd()) {\n          typedValues.push(readValue(type.getFirstTypeParameter()));\n        }\n\n        return new variadic_1.VariadicValue(type, typedValues);\n      } else if (type instanceof composite_1.CompositeType) {\n        let typedValues = [];\n\n        for (const typeParameter of type.getTypeParameters()) {\n          typedValues.push(readValue(typeParameter));\n        }\n\n        return new composite_1.CompositeValue(type, typedValues);\n      } else {\n        // Non-composite (singular), non-variadic (fixed) type.\n        // The only branching without a recursive call.\n        let typedValue = decodeNextBuffer(type);\n        return typedValue;\n      }\n    }\n\n    function decodeNextBuffer(type) {\n      if (hasReachedTheEnd()) {\n        return null;\n      }\n\n      let buffer = buffers[bufferIndex++];\n      let decodedValue = Codec.decodeTopLevel(buffer, type);\n      return decodedValue;\n    }\n\n    function hasReachedTheEnd() {\n      return bufferIndex >= numBuffers;\n    }\n\n    return values;\n  }\n  /**\n   * Serializes a set of typed values into an arguments string (e.g. aa@bb@@cc).\n   */\n\n\n  valuesToString(values) {\n    let strings = this.valuesToStrings(values);\n    let argumentsString = strings.join(exports.ArgumentsSeparator);\n    let count = strings.length;\n    return {\n      argumentsString,\n      count\n    };\n  }\n  /**\n   * Serializes a set of typed values into a set of strings.\n   */\n\n\n  valuesToStrings(values) {\n    let buffers = this.valuesToBuffers(values);\n    let strings = buffers.map(buffer => buffer.toString(\"hex\"));\n    return strings;\n  }\n  /**\n   * Serializes a set of typed values into a set of strings buffers.\n   * Variadic types and composite types might result into none, one or more buffers.\n   */\n\n\n  valuesToBuffers(values) {\n    // TODO: Refactor, split (function is quite complex).\n    let buffers = [];\n\n    for (const value of values) {\n      handleValue(value);\n    } // This is a recursive function. It appends to the \"buffers\" variable.\n\n\n    function handleValue(value) {\n      // TODO: Use matchers.\n      if (value instanceof algebraic_1.OptionalValue) {\n        if (value.isSet()) {\n          handleValue(value.getTypedValue());\n        }\n      } else if (value instanceof variadic_1.VariadicValue) {\n        for (const item of value.getItems()) {\n          handleValue(item);\n        }\n      } else if (value instanceof composite_1.CompositeValue) {\n        for (const item of value.getItems()) {\n          handleValue(item);\n        }\n      } else {\n        // Non-composite (singular), non-variadic (fixed) type.\n        // The only branching without a recursive call.\n        let buffer = Codec.encodeTopLevel(value);\n        buffers.push(buffer);\n      }\n    }\n\n    return buffers;\n  }\n\n}\n\nexports.ArgSerializer = ArgSerializer;","map":{"version":3,"sources":["../../src/smartcontracts/argSerializer.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AAEA,MAAA,WAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;;AACA,MAAA,WAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;;AAEa,OAAA,CAAA,kBAAA,GAAqB,GAArB;AAEb;;AAEG;;AACH,MAAM,KAAK,GAAG,IAAI,OAAA,CAAA,WAAJ,EAAd;;AAEA,MAAa,aAAb,CAA0B;EACtB;;AAEG;EACH,cAAc,CAAC,YAAD,EAAuB,UAAvB,EAAgE;IAC1E,IAAI,OAAO,GAAG,KAAK,eAAL,CAAqB,YAArB,CAAd;IACA,IAAI,MAAM,GAAG,KAAK,eAAL,CAAqB,OAArB,EAA8B,UAA9B,CAAb;IACA,OAAO,MAAP;EACH;EAED;;AAEG;;;EACH,eAAe,CAAC,YAAD,EAAqB;IAChC;IACA,OAAO,YAAY,CAAC,KAAb,CAAmB,OAAA,CAAA,kBAAnB,EAAuC,GAAvC,CAA2C,IAAI,IAAI,MAAM,CAAC,IAAP,CAAY,IAAZ,EAAkB,KAAlB,CAAnD,CAAP;EACH;EAED;;AAEG;;;EACH,eAAe,CAAC,OAAD,EAAoB,UAApB,EAA6D;IACxE;IAEA,OAAO,GAAG,OAAO,IAAI,EAArB;IAEA,IAAI,MAAM,GAAiB,EAA3B;IACA,IAAI,WAAW,GAAG,CAAlB;IACA,IAAI,UAAU,GAAG,OAAO,CAAC,MAAzB;;IAEA,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,UAAU,CAAC,MAA/B,EAAuC,CAAC,EAAxC,EAA4C;MACxC,IAAI,SAAS,GAAG,UAAU,CAAC,CAAD,CAA1B;MACA,IAAI,IAAI,GAAG,SAAS,CAAC,IAArB;MACA,IAAI,KAAK,GAAG,SAAS,CAAC,IAAD,CAArB;MACA,MAAM,CAAC,IAAP,CAAY,KAAZ;IACH,CAduE,CAgBxE;;;IACA,SAAS,SAAT,CAAmB,IAAnB,EAA6B;MACzB;MAEA,IAAI,IAAI,YAAY,WAAA,CAAA,YAApB,EAAkC;QAC9B,IAAI,UAAU,GAAG,SAAS,CAAC,IAAI,CAAC,qBAAL,EAAD,CAA1B;QACA,OAAO,IAAI,WAAA,CAAA,aAAJ,CAAkB,IAAlB,EAAwB,UAAxB,CAAP;MACH,CAHD,MAGO,IAAI,IAAI,YAAY,UAAA,CAAA,YAApB,EAAkC;QACrC,IAAI,WAAW,GAAG,EAAlB;;QAEA,OAAO,CAAC,gBAAgB,EAAxB,EAA4B;UACxB,WAAW,CAAC,IAAZ,CAAiB,SAAS,CAAC,IAAI,CAAC,qBAAL,EAAD,CAA1B;QACH;;QAED,OAAO,IAAI,UAAA,CAAA,aAAJ,CAAkB,IAAlB,EAAwB,WAAxB,CAAP;MACH,CARM,MAQA,IAAI,IAAI,YAAY,WAAA,CAAA,aAApB,EAAmC;QACtC,IAAI,WAAW,GAAG,EAAlB;;QAEA,KAAK,MAAM,aAAX,IAA4B,IAAI,CAAC,iBAAL,EAA5B,EAAsD;UAClD,WAAW,CAAC,IAAZ,CAAiB,SAAS,CAAC,aAAD,CAA1B;QACH;;QAED,OAAO,IAAI,WAAA,CAAA,cAAJ,CAAmB,IAAnB,EAAyB,WAAzB,CAAP;MACH,CARM,MAQA;QACH;QACA;QACA,IAAI,UAAU,GAAG,gBAAgB,CAAC,IAAD,CAAjC;QACA,OAAO,UAAP;MACH;IACJ;;IAED,SAAS,gBAAT,CAA0B,IAA1B,EAAoC;MAChC,IAAI,gBAAgB,EAApB,EAAwB;QACpB,OAAO,IAAP;MACH;;MAED,IAAI,MAAM,GAAG,OAAO,CAAC,WAAW,EAAZ,CAApB;MACA,IAAI,YAAY,GAAG,KAAK,CAAC,cAAN,CAAqB,MAArB,EAA6B,IAA7B,CAAnB;MACA,OAAO,YAAP;IACH;;IAED,SAAS,gBAAT,GAAyB;MACrB,OAAO,WAAW,IAAI,UAAtB;IACH;;IAED,OAAO,MAAP;EACH;EAED;;AAEG;;;EACH,cAAc,CAAC,MAAD,EAAqB;IAC/B,IAAI,OAAO,GAAG,KAAK,eAAL,CAAqB,MAArB,CAAd;IACA,IAAI,eAAe,GAAG,OAAO,CAAC,IAAR,CAAa,OAAA,CAAA,kBAAb,CAAtB;IACA,IAAI,KAAK,GAAG,OAAO,CAAC,MAApB;IACA,OAAO;MAAE,eAAF;MAAmB;IAAnB,CAAP;EACH;EAED;;AAEG;;;EACH,eAAe,CAAC,MAAD,EAAqB;IAChC,IAAI,OAAO,GAAG,KAAK,eAAL,CAAqB,MAArB,CAAd;IACA,IAAI,OAAO,GAAG,OAAO,CAAC,GAAR,CAAY,MAAM,IAAI,MAAM,CAAC,QAAP,CAAgB,KAAhB,CAAtB,CAAd;IACA,OAAO,OAAP;EACH;EAED;;;AAGG;;;EACH,eAAe,CAAC,MAAD,EAAqB;IAChC;IAEA,IAAI,OAAO,GAAa,EAAxB;;IAEA,KAAK,MAAM,KAAX,IAAoB,MAApB,EAA4B;MACxB,WAAW,CAAC,KAAD,CAAX;IACH,CAP+B,CAShC;;;IACA,SAAS,WAAT,CAAqB,KAArB,EAAsC;MAClC;MAEA,IAAI,KAAK,YAAY,WAAA,CAAA,aAArB,EAAoC;QAChC,IAAI,KAAK,CAAC,KAAN,EAAJ,EAAmB;UACf,WAAW,CAAC,KAAK,CAAC,aAAN,EAAD,CAAX;QACH;MACJ,CAJD,MAIO,IAAI,KAAK,YAAY,UAAA,CAAA,aAArB,EAAoC;QACvC,KAAK,MAAM,IAAX,IAAmB,KAAK,CAAC,QAAN,EAAnB,EAAqC;UACjC,WAAW,CAAC,IAAD,CAAX;QACH;MACJ,CAJM,MAIA,IAAI,KAAK,YAAY,WAAA,CAAA,cAArB,EAAqC;QACxC,KAAK,MAAM,IAAX,IAAmB,KAAK,CAAC,QAAN,EAAnB,EAAqC;UACjC,WAAW,CAAC,IAAD,CAAX;QACH;MACJ,CAJM,MAIA;QACH;QACA;QACA,IAAI,MAAM,GAAW,KAAK,CAAC,cAAN,CAAqB,KAArB,CAArB;QACA,OAAO,CAAC,IAAR,CAAa,MAAb;MACH;IACJ;;IAED,OAAO,OAAP;EACH;;AA9IqB;;AAA1B,OAAA,CAAA,aAAA,GAAA,aAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ArgSerializer = exports.ArgumentsSeparator = void 0;\nconst codec_1 = require(\"./codec\");\nconst composite_1 = require(\"./typesystem/composite\");\nconst variadic_1 = require(\"./typesystem/variadic\");\nconst algebraic_1 = require(\"./typesystem/algebraic\");\nexports.ArgumentsSeparator = \"@\";\n/**\n * For the moment, this is the only codec used.\n */\nconst Codec = new codec_1.BinaryCodec();\nclass ArgSerializer {\n    /**\n     * Reads typed values from an arguments string (e.g. aa@bb@@cc), given parameter definitions.\n     */\n    stringToValues(joinedString, parameters) {\n        let buffers = this.stringToBuffers(joinedString);\n        let values = this.buffersToValues(buffers, parameters);\n        return values;\n    }\n    /**\n     * Reads raw buffers from an arguments string (e.g. aa@bb@@cc).\n     */\n    stringToBuffers(joinedString) {\n        // We also keep the zero-length buffers (they could encode missing options, Option<T>).\n        return joinedString.split(exports.ArgumentsSeparator).map(item => Buffer.from(item, \"hex\"));\n    }\n    /**\n     * Decodes a set of buffers into a set of typed values, given parameter definitions.\n     */\n    buffersToValues(buffers, parameters) {\n        // TODO: Refactor, split (function is quite complex).\n        buffers = buffers || [];\n        let values = [];\n        let bufferIndex = 0;\n        let numBuffers = buffers.length;\n        for (let i = 0; i < parameters.length; i++) {\n            let parameter = parameters[i];\n            let type = parameter.type;\n            let value = readValue(type);\n            values.push(value);\n        }\n        // This is a recursive function.\n        function readValue(type) {\n            // TODO: Use matchers.\n            if (type instanceof algebraic_1.OptionalType) {\n                let typedValue = readValue(type.getFirstTypeParameter());\n                return new algebraic_1.OptionalValue(type, typedValue);\n            }\n            else if (type instanceof variadic_1.VariadicType) {\n                let typedValues = [];\n                while (!hasReachedTheEnd()) {\n                    typedValues.push(readValue(type.getFirstTypeParameter()));\n                }\n                return new variadic_1.VariadicValue(type, typedValues);\n            }\n            else if (type instanceof composite_1.CompositeType) {\n                let typedValues = [];\n                for (const typeParameter of type.getTypeParameters()) {\n                    typedValues.push(readValue(typeParameter));\n                }\n                return new composite_1.CompositeValue(type, typedValues);\n            }\n            else {\n                // Non-composite (singular), non-variadic (fixed) type.\n                // The only branching without a recursive call.\n                let typedValue = decodeNextBuffer(type);\n                return typedValue;\n            }\n        }\n        function decodeNextBuffer(type) {\n            if (hasReachedTheEnd()) {\n                return null;\n            }\n            let buffer = buffers[bufferIndex++];\n            let decodedValue = Codec.decodeTopLevel(buffer, type);\n            return decodedValue;\n        }\n        function hasReachedTheEnd() {\n            return bufferIndex >= numBuffers;\n        }\n        return values;\n    }\n    /**\n     * Serializes a set of typed values into an arguments string (e.g. aa@bb@@cc).\n     */\n    valuesToString(values) {\n        let strings = this.valuesToStrings(values);\n        let argumentsString = strings.join(exports.ArgumentsSeparator);\n        let count = strings.length;\n        return { argumentsString, count };\n    }\n    /**\n     * Serializes a set of typed values into a set of strings.\n     */\n    valuesToStrings(values) {\n        let buffers = this.valuesToBuffers(values);\n        let strings = buffers.map(buffer => buffer.toString(\"hex\"));\n        return strings;\n    }\n    /**\n     * Serializes a set of typed values into a set of strings buffers.\n     * Variadic types and composite types might result into none, one or more buffers.\n     */\n    valuesToBuffers(values) {\n        // TODO: Refactor, split (function is quite complex).\n        let buffers = [];\n        for (const value of values) {\n            handleValue(value);\n        }\n        // This is a recursive function. It appends to the \"buffers\" variable.\n        function handleValue(value) {\n            // TODO: Use matchers.\n            if (value instanceof algebraic_1.OptionalValue) {\n                if (value.isSet()) {\n                    handleValue(value.getTypedValue());\n                }\n            }\n            else if (value instanceof variadic_1.VariadicValue) {\n                for (const item of value.getItems()) {\n                    handleValue(item);\n                }\n            }\n            else if (value instanceof composite_1.CompositeValue) {\n                for (const item of value.getItems()) {\n                    handleValue(item);\n                }\n            }\n            else {\n                // Non-composite (singular), non-variadic (fixed) type.\n                // The only branching without a recursive call.\n                let buffer = Codec.encodeTopLevel(value);\n                buffers.push(buffer);\n            }\n        }\n        return buffers;\n    }\n}\nexports.ArgSerializer = ArgSerializer;\n//# sourceMappingURL=argSerializer.js.map"]},"metadata":{},"sourceType":"script"}