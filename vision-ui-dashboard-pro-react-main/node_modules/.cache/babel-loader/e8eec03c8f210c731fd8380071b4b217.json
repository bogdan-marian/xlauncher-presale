{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Struct = exports.StructType = void 0;\n\nconst fields_1 = require(\"./fields\");\n\nconst types_1 = require(\"./types\");\n\nclass StructType extends types_1.CustomType {\n  constructor(name, fieldsDefinitions) {\n    super(name);\n    this.fieldsDefinitions = [];\n    this.fieldsDefinitions = fieldsDefinitions;\n  }\n\n  static fromJSON(json) {\n    let definitions = (json.fields || []).map(definition => fields_1.FieldDefinition.fromJSON(definition));\n    return new StructType(json.name, definitions);\n  }\n\n  getFieldsDefinitions() {\n    return this.fieldsDefinitions;\n  }\n\n}\n\nexports.StructType = StructType; // TODO: implement setField(), convenience method.\n// TODO: Hold fields in a map (by name), and use the order within \"field definitions\" to perform codec operations.\n\nclass Struct extends types_1.TypedValue {\n  /**\n   * Currently, one can only set fields at initialization time. Construction will be improved at a later time.\n   */\n  constructor(type, fields) {\n    super(type);\n    this.fields = [];\n    this.fields = fields;\n    this.checkTyping();\n  }\n\n  checkTyping() {\n    let type = this.getType();\n    let definitions = type.getFieldsDefinitions();\n    fields_1.Fields.checkTyping(this.fields, definitions);\n  }\n\n  getFields() {\n    return this.fields;\n  }\n\n  valueOf() {\n    let result = {};\n\n    for (const field of this.fields) {\n      result[field.name] = field.value.valueOf();\n    }\n\n    return result;\n  }\n\n  equals(other) {\n    if (!this.getType().equals(other.getType())) {\n      return false;\n    }\n\n    let selfFields = this.getFields();\n    let otherFields = other.getFields();\n    return fields_1.Fields.equals(selfFields, otherFields);\n  }\n\n}\n\nexports.Struct = Struct;","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/struct.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AAEA,MAAa,UAAb,SAAgC,OAAA,CAAA,UAAhC,CAA0C;EAGtC,WAAA,CAAY,IAAZ,EAA0B,iBAA1B,EAA8D;IAC1D,MAAM,IAAN;IAHa,KAAA,iBAAA,GAAuC,EAAvC;IAIb,KAAK,iBAAL,GAAyB,iBAAzB;EACH;;EAEc,OAAR,QAAQ,CAAC,IAAD,EAAsC;IACjD,IAAI,WAAW,GAAG,CAAC,IAAI,CAAC,MAAL,IAAe,EAAhB,EAAoB,GAApB,CAAwB,UAAU,IAAI,QAAA,CAAA,eAAA,CAAgB,QAAhB,CAAyB,UAAzB,CAAtC,CAAlB;IACA,OAAO,IAAI,UAAJ,CAAe,IAAI,CAAC,IAApB,EAA0B,WAA1B,CAAP;EACH;;EAED,oBAAoB,GAAA;IAChB,OAAO,KAAK,iBAAZ;EACH;;AAfqC;;AAA1C,OAAA,CAAA,UAAA,GAAA,UAAA,C,CAkBA;AACA;;AACA,MAAa,MAAb,SAA4B,OAAA,CAAA,UAA5B,CAAsC;EAGlC;;AAEG;EACH,WAAA,CAAY,IAAZ,EAA8B,MAA9B,EAA6C;IACzC,MAAM,IAAN;IANa,KAAA,MAAA,GAAkB,EAAlB;IAOb,KAAK,MAAL,GAAc,MAAd;IAEA,KAAK,WAAL;EACH;;EAEO,WAAW,GAAA;IACf,IAAI,IAAI,GAAe,KAAK,OAAL,EAAvB;IACA,IAAI,WAAW,GAAG,IAAI,CAAC,oBAAL,EAAlB;IACA,QAAA,CAAA,MAAA,CAAO,WAAP,CAAmB,KAAK,MAAxB,EAAgC,WAAhC;EACH;;EAED,SAAS,GAAA;IACL,OAAO,KAAK,MAAZ;EACH;;EAED,OAAO,GAAA;IACH,IAAI,MAAM,GAAQ,EAAlB;;IAEA,KAAK,MAAM,KAAX,IAAoB,KAAK,MAAzB,EAAiC;MAC7B,MAAM,CAAC,KAAK,CAAC,IAAP,CAAN,GAAqB,KAAK,CAAC,KAAN,CAAY,OAAZ,EAArB;IACH;;IAED,OAAO,MAAP;EACH;;EAED,MAAM,CAAC,KAAD,EAAc;IAChB,IAAI,CAAC,KAAK,OAAL,GAAe,MAAf,CAAsB,KAAK,CAAC,OAAN,EAAtB,CAAL,EAA6C;MACzC,OAAO,KAAP;IACH;;IAED,IAAI,UAAU,GAAG,KAAK,SAAL,EAAjB;IACA,IAAI,WAAW,GAAG,KAAK,CAAC,SAAN,EAAlB;IAEA,OAAO,QAAA,CAAA,MAAA,CAAO,MAAP,CAAc,UAAd,EAA0B,WAA1B,CAAP;EACH;;AA1CiC;;AAAtC,OAAA,CAAA,MAAA,GAAA,MAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Struct = exports.StructType = void 0;\nconst fields_1 = require(\"./fields\");\nconst types_1 = require(\"./types\");\nclass StructType extends types_1.CustomType {\n    constructor(name, fieldsDefinitions) {\n        super(name);\n        this.fieldsDefinitions = [];\n        this.fieldsDefinitions = fieldsDefinitions;\n    }\n    static fromJSON(json) {\n        let definitions = (json.fields || []).map(definition => fields_1.FieldDefinition.fromJSON(definition));\n        return new StructType(json.name, definitions);\n    }\n    getFieldsDefinitions() {\n        return this.fieldsDefinitions;\n    }\n}\nexports.StructType = StructType;\n// TODO: implement setField(), convenience method.\n// TODO: Hold fields in a map (by name), and use the order within \"field definitions\" to perform codec operations.\nclass Struct extends types_1.TypedValue {\n    /**\n     * Currently, one can only set fields at initialization time. Construction will be improved at a later time.\n     */\n    constructor(type, fields) {\n        super(type);\n        this.fields = [];\n        this.fields = fields;\n        this.checkTyping();\n    }\n    checkTyping() {\n        let type = this.getType();\n        let definitions = type.getFieldsDefinitions();\n        fields_1.Fields.checkTyping(this.fields, definitions);\n    }\n    getFields() {\n        return this.fields;\n    }\n    valueOf() {\n        let result = {};\n        for (const field of this.fields) {\n            result[field.name] = field.value.valueOf();\n        }\n        return result;\n    }\n    equals(other) {\n        if (!this.getType().equals(other.getType())) {\n            return false;\n        }\n        let selfFields = this.getFields();\n        let otherFields = other.getFields();\n        return fields_1.Fields.equals(selfFields, otherFields);\n    }\n}\nexports.Struct = Struct;\n//# sourceMappingURL=struct.js.map"]},"metadata":{},"sourceType":"script"}