{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NativeSerializer = void 0;\n\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\n\nconst _1 = require(\".\");\n\nconst __1 = require(\"..\");\n\nconst testutils_1 = require(\"../testutils\");\n\nconst argumentErrorContext_1 = require(\"./argumentErrorContext\");\n\nconst smartContract_1 = require(\"./smartContract\");\n\nconst typesystem_1 = require(\"./typesystem\");\n\nconst contractWrapper_1 = require(\"./wrapper/contractWrapper\");\n\nvar NativeSerializer;\n\n(function (NativeSerializer) {\n  /**\n   * Interprets a set of native javascript values into a set of typed values, given parameter definitions.\n   */\n  function nativeToTypedValues(args, endpoint) {\n    args = args || [];\n    args = handleVariadicArgsAndRePack(args, endpoint);\n    let parameters = endpoint.input;\n    let values = [];\n\n    for (let i in parameters) {\n      let parameter = parameters[i];\n      let errorContext = new argumentErrorContext_1.ArgumentErrorContext(endpoint.name, i, parameter);\n      let value = convertToTypedValue(args[i], parameter.type, errorContext);\n      values.push(value);\n    }\n\n    return values;\n  }\n\n  NativeSerializer.nativeToTypedValues = nativeToTypedValues;\n\n  function handleVariadicArgsAndRePack(args, endpoint) {\n    let parameters = endpoint.input;\n    let {\n      min,\n      max,\n      variadic\n    } = getArgumentsCardinality(parameters);\n\n    if (!(min <= args.length && args.length <= max)) {\n      throw new __1.ErrInvalidArgument(`Wrong number of arguments for endpoint ${endpoint.name}: expected between ${min} and ${max} arguments, have ${args.length}`);\n    }\n\n    if (variadic) {\n      let lastArgIndex = parameters.length - 1;\n      let lastArg = args.slice(lastArgIndex);\n      args[lastArgIndex] = lastArg;\n    }\n\n    return args;\n  } // A function may have one of the following formats:\n  // f(arg1, arg2, optional<arg3>, optional<arg4>) returns { min: 2, max: 4, variadic: false }\n  // f(arg1, variadic<bytes>) returns { min: 1, max: Infinity, variadic: true }\n  // f(arg1, arg2, optional<arg3>, arg4, optional<arg5>, variadic<bytes>) returns { min: 2, max: Infinity, variadic: true }\n\n\n  function getArgumentsCardinality(parameters) {\n    let reversed = [...parameters].reverse(); // keep the original unchanged\n\n    let min = parameters.length;\n    let max = parameters.length;\n    let variadic = false;\n\n    if (reversed.length > 0 && reversed[0].type.getCardinality().isComposite()) {\n      max = Infinity;\n      variadic = true;\n    }\n\n    for (let parameter of reversed) {\n      if (parameter.type.getCardinality().isSingular()) {\n        break;\n      }\n\n      min -= 1;\n    }\n\n    return {\n      min,\n      max,\n      variadic\n    };\n  }\n\n  function convertToTypedValue(native, type, errorContext) {\n    if (type instanceof _1.OptionType) {\n      return toOptionValue(native, type, errorContext);\n    }\n\n    if (type instanceof _1.OptionalType) {\n      return toOptionalValue(native, type, errorContext);\n    }\n\n    if (type instanceof _1.VariadicType) {\n      return toVariadicValue(native, type, errorContext);\n    }\n\n    if (type instanceof _1.CompositeType) {\n      return toCompositeValue(native, type, errorContext);\n    }\n\n    if (type instanceof _1.TupleType) {\n      return toTupleValue(native, type, errorContext);\n    }\n\n    if (type instanceof typesystem_1.StructType) {\n      return toStructValue(native, type, errorContext);\n    }\n\n    if (type instanceof _1.ListType) {\n      return toListValue(native, type, errorContext);\n    }\n\n    if (type instanceof _1.PrimitiveType) {\n      return toPrimitive(native, type, errorContext);\n    }\n\n    errorContext.throwError(`convertToTypedValue: unhandled type ${type}`);\n  }\n\n  function toOptionValue(native, type, errorContext) {\n    if (native == null) {\n      return _1.OptionValue.newMissing();\n    }\n\n    let converted = convertToTypedValue(native, type.getFirstTypeParameter(), errorContext);\n    return _1.OptionValue.newProvided(converted);\n  }\n\n  function toOptionalValue(native, type, errorContext) {\n    if (native == null) {\n      return new _1.OptionalValue(type);\n    }\n\n    let converted = convertToTypedValue(native, type.getFirstTypeParameter(), errorContext);\n    return new _1.OptionalValue(type, converted);\n  }\n\n  function toVariadicValue(native, type, errorContext) {\n    if (native == null) {\n      native = [];\n    }\n\n    if (native.map === undefined) {\n      errorContext.convertError(native, \"Variadic\");\n    }\n\n    let converted = native.map(function (item) {\n      return convertToTypedValue(item, type.getFirstTypeParameter(), errorContext);\n    });\n    return new _1.VariadicValue(type, converted);\n  }\n\n  function toListValue(native, type, errorContext) {\n    if (native.map === undefined) {\n      errorContext.convertError(native, \"List\");\n    }\n\n    let converted = native.map(function (item) {\n      return convertToTypedValue(item, type.getFirstTypeParameter(), errorContext);\n    });\n    return new _1.List(type, converted);\n  }\n\n  function toCompositeValue(native, type, errorContext) {\n    let typedValues = [];\n    let typeParameters = type.getTypeParameters();\n    errorContext.guardSameLength(native, typeParameters);\n\n    for (let i in typeParameters) {\n      typedValues.push(convertToTypedValue(native[i], typeParameters[i], errorContext));\n    }\n\n    return new _1.CompositeValue(type, typedValues);\n  }\n\n  function toTupleValue(native, type, errorContext) {\n    let typedValues = [];\n    const fields = type.getFieldsDefinitions();\n    errorContext.guardSameLength(native, fields);\n\n    for (let i in fields) {\n      typedValues.push(convertToTypedValue(native[i], fields[i].type, errorContext));\n    }\n\n    return typesystem_1.Tuple.fromItems(typedValues);\n  }\n\n  function toStructValue(native, type, errorContext) {\n    let structFieldValues = [];\n    const fields = type.getFieldsDefinitions();\n\n    for (let i in fields) {\n      const fieldName = fields[i].name;\n      errorContext.guardHasField(native, fieldName);\n      const fieldNativeValue = native[fieldName];\n      const fieldTypedValue = convertToTypedValue(fieldNativeValue, fields[i].type, errorContext);\n      structFieldValues.push(new typesystem_1.Field(fieldTypedValue, fieldName));\n    }\n\n    return new typesystem_1.Struct(type, structFieldValues);\n  }\n\n  function toPrimitive(native, type, errorContext) {\n    if (type instanceof _1.NumericalType) {\n      let number = new bignumber_js_1.default(native);\n      return convertNumericalType(number, type, errorContext);\n    }\n\n    if (type instanceof _1.BytesType) {\n      return convertNativeToBytesValue(native, errorContext);\n    }\n\n    if (type instanceof _1.AddressType) {\n      return new _1.AddressValue(convertNativeToAddress(native, errorContext));\n    }\n\n    if (type instanceof _1.BooleanType) {\n      return new _1.BooleanValue(native);\n    }\n\n    if (type instanceof _1.TokenIdentifierType) {\n      return new _1.TokenIdentifierValue(convertNativeToBuffer(native, errorContext));\n    }\n\n    errorContext.throwError(`(function: toPrimitive) unsupported type ${type}`);\n  }\n\n  function convertNativeToBytesValue(native, errorContext) {\n    if (native === undefined) {\n      errorContext.convertError(native, \"BytesValue\");\n    }\n\n    if (native instanceof _1.Code) {\n      return _1.BytesValue.fromHex(native.toString());\n    }\n\n    if (native instanceof Buffer) {\n      return new _1.BytesValue(native);\n    }\n\n    if (typeof native === \"string\") {\n      return _1.BytesValue.fromUTF8(native);\n    }\n\n    if (native.getTokenIdentifier) {\n      return _1.BytesValue.fromUTF8(native.getTokenIdentifier());\n    }\n\n    errorContext.convertError(native, \"BytesValue\");\n  }\n\n  function convertNativeToBuffer(native, errorContext) {\n    if (native === undefined) {\n      errorContext.convertError(native, \"Buffer\");\n    }\n\n    if (native instanceof Buffer) {\n      return native;\n    }\n\n    if (typeof native === \"string\") {\n      return Buffer.from(native);\n    }\n\n    if (native.getTokenIdentifier) {\n      return Buffer.from(native.getTokenIdentifier());\n    }\n\n    errorContext.convertError(native, \"Buffer\");\n  }\n\n  function convertNativeToAddress(native, errorContext) {\n    switch (native.constructor) {\n      case __1.Address:\n      case Buffer:\n      case String:\n        return new __1.Address(native);\n\n      case contractWrapper_1.ContractWrapper:\n        return native.getAddress();\n\n      case smartContract_1.SmartContract:\n        return native.getAddress();\n\n      case testutils_1.TestWallet:\n        return native.address;\n\n      default:\n        errorContext.convertError(native, \"Address\");\n    }\n  }\n\n  NativeSerializer.convertNativeToAddress = convertNativeToAddress;\n\n  function convertNumericalType(number, type, errorContext) {\n    switch (type.constructor) {\n      case _1.U8Type:\n        return new _1.U8Value(number);\n\n      case _1.I8Type:\n        return new _1.I8Value(number);\n\n      case _1.U16Type:\n        return new _1.U16Value(number);\n\n      case _1.I16Type:\n        return new _1.I16Value(number);\n\n      case _1.U32Type:\n        return new _1.U32Value(number);\n\n      case _1.I32Type:\n        return new _1.I32Value(number);\n\n      case _1.U64Type:\n        return new _1.U64Value(number);\n\n      case _1.I64Type:\n        return new _1.I64Value(number);\n\n      case _1.BigUIntType:\n        return new _1.BigUIntValue(number);\n\n      case _1.BigIntType:\n        return new _1.BigIntValue(number);\n\n      default:\n        errorContext.unhandledType(\"convertNumericalType\", type);\n    }\n  }\n})(NativeSerializer = exports.NativeSerializer || (exports.NativeSerializer = {}));","map":{"version":3,"sources":["../../src/smartcontracts/nativeSerializer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NativeSerializer = void 0;\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nconst _1 = require(\".\");\nconst __1 = require(\"..\");\nconst testutils_1 = require(\"../testutils\");\nconst argumentErrorContext_1 = require(\"./argumentErrorContext\");\nconst smartContract_1 = require(\"./smartContract\");\nconst typesystem_1 = require(\"./typesystem\");\nconst contractWrapper_1 = require(\"./wrapper/contractWrapper\");\nvar NativeSerializer;\n(function (NativeSerializer) {\n    /**\n     * Interprets a set of native javascript values into a set of typed values, given parameter definitions.\n     */\n    function nativeToTypedValues(args, endpoint) {\n        args = args || [];\n        args = handleVariadicArgsAndRePack(args, endpoint);\n        let parameters = endpoint.input;\n        let values = [];\n        for (let i in parameters) {\n            let parameter = parameters[i];\n            let errorContext = new argumentErrorContext_1.ArgumentErrorContext(endpoint.name, i, parameter);\n            let value = convertToTypedValue(args[i], parameter.type, errorContext);\n            values.push(value);\n        }\n        return values;\n    }\n    NativeSerializer.nativeToTypedValues = nativeToTypedValues;\n    function handleVariadicArgsAndRePack(args, endpoint) {\n        let parameters = endpoint.input;\n        let { min, max, variadic } = getArgumentsCardinality(parameters);\n        if (!(min <= args.length && args.length <= max)) {\n            throw new __1.ErrInvalidArgument(`Wrong number of arguments for endpoint ${endpoint.name}: expected between ${min} and ${max} arguments, have ${args.length}`);\n        }\n        if (variadic) {\n            let lastArgIndex = parameters.length - 1;\n            let lastArg = args.slice(lastArgIndex);\n            args[lastArgIndex] = lastArg;\n        }\n        return args;\n    }\n    // A function may have one of the following formats:\n    // f(arg1, arg2, optional<arg3>, optional<arg4>) returns { min: 2, max: 4, variadic: false }\n    // f(arg1, variadic<bytes>) returns { min: 1, max: Infinity, variadic: true }\n    // f(arg1, arg2, optional<arg3>, arg4, optional<arg5>, variadic<bytes>) returns { min: 2, max: Infinity, variadic: true }\n    function getArgumentsCardinality(parameters) {\n        let reversed = [...parameters].reverse(); // keep the original unchanged\n        let min = parameters.length;\n        let max = parameters.length;\n        let variadic = false;\n        if (reversed.length > 0 && reversed[0].type.getCardinality().isComposite()) {\n            max = Infinity;\n            variadic = true;\n        }\n        for (let parameter of reversed) {\n            if (parameter.type.getCardinality().isSingular()) {\n                break;\n            }\n            min -= 1;\n        }\n        return { min, max, variadic };\n    }\n    function convertToTypedValue(native, type, errorContext) {\n        if (type instanceof _1.OptionType) {\n            return toOptionValue(native, type, errorContext);\n        }\n        if (type instanceof _1.OptionalType) {\n            return toOptionalValue(native, type, errorContext);\n        }\n        if (type instanceof _1.VariadicType) {\n            return toVariadicValue(native, type, errorContext);\n        }\n        if (type instanceof _1.CompositeType) {\n            return toCompositeValue(native, type, errorContext);\n        }\n        if (type instanceof _1.TupleType) {\n            return toTupleValue(native, type, errorContext);\n        }\n        if (type instanceof typesystem_1.StructType) {\n            return toStructValue(native, type, errorContext);\n        }\n        if (type instanceof _1.ListType) {\n            return toListValue(native, type, errorContext);\n        }\n        if (type instanceof _1.PrimitiveType) {\n            return toPrimitive(native, type, errorContext);\n        }\n        errorContext.throwError(`convertToTypedValue: unhandled type ${type}`);\n    }\n    function toOptionValue(native, type, errorContext) {\n        if (native == null) {\n            return _1.OptionValue.newMissing();\n        }\n        let converted = convertToTypedValue(native, type.getFirstTypeParameter(), errorContext);\n        return _1.OptionValue.newProvided(converted);\n    }\n    function toOptionalValue(native, type, errorContext) {\n        if (native == null) {\n            return new _1.OptionalValue(type);\n        }\n        let converted = convertToTypedValue(native, type.getFirstTypeParameter(), errorContext);\n        return new _1.OptionalValue(type, converted);\n    }\n    function toVariadicValue(native, type, errorContext) {\n        if (native == null) {\n            native = [];\n        }\n        if (native.map === undefined) {\n            errorContext.convertError(native, \"Variadic\");\n        }\n        let converted = native.map(function (item) {\n            return convertToTypedValue(item, type.getFirstTypeParameter(), errorContext);\n        });\n        return new _1.VariadicValue(type, converted);\n    }\n    function toListValue(native, type, errorContext) {\n        if (native.map === undefined) {\n            errorContext.convertError(native, \"List\");\n        }\n        let converted = native.map(function (item) {\n            return convertToTypedValue(item, type.getFirstTypeParameter(), errorContext);\n        });\n        return new _1.List(type, converted);\n    }\n    function toCompositeValue(native, type, errorContext) {\n        let typedValues = [];\n        let typeParameters = type.getTypeParameters();\n        errorContext.guardSameLength(native, typeParameters);\n        for (let i in typeParameters) {\n            typedValues.push(convertToTypedValue(native[i], typeParameters[i], errorContext));\n        }\n        return new _1.CompositeValue(type, typedValues);\n    }\n    function toTupleValue(native, type, errorContext) {\n        let typedValues = [];\n        const fields = type.getFieldsDefinitions();\n        errorContext.guardSameLength(native, fields);\n        for (let i in fields) {\n            typedValues.push(convertToTypedValue(native[i], fields[i].type, errorContext));\n        }\n        return typesystem_1.Tuple.fromItems(typedValues);\n    }\n    function toStructValue(native, type, errorContext) {\n        let structFieldValues = [];\n        const fields = type.getFieldsDefinitions();\n        for (let i in fields) {\n            const fieldName = fields[i].name;\n            errorContext.guardHasField(native, fieldName);\n            const fieldNativeValue = native[fieldName];\n            const fieldTypedValue = convertToTypedValue(fieldNativeValue, fields[i].type, errorContext);\n            structFieldValues.push(new typesystem_1.Field(fieldTypedValue, fieldName));\n        }\n        return new typesystem_1.Struct(type, structFieldValues);\n    }\n    function toPrimitive(native, type, errorContext) {\n        if (type instanceof _1.NumericalType) {\n            let number = new bignumber_js_1.default(native);\n            return convertNumericalType(number, type, errorContext);\n        }\n        if (type instanceof _1.BytesType) {\n            return convertNativeToBytesValue(native, errorContext);\n        }\n        if (type instanceof _1.AddressType) {\n            return new _1.AddressValue(convertNativeToAddress(native, errorContext));\n        }\n        if (type instanceof _1.BooleanType) {\n            return new _1.BooleanValue(native);\n        }\n        if (type instanceof _1.TokenIdentifierType) {\n            return new _1.TokenIdentifierValue(convertNativeToBuffer(native, errorContext));\n        }\n        errorContext.throwError(`(function: toPrimitive) unsupported type ${type}`);\n    }\n    function convertNativeToBytesValue(native, errorContext) {\n        if (native === undefined) {\n            errorContext.convertError(native, \"BytesValue\");\n        }\n        if (native instanceof _1.Code) {\n            return _1.BytesValue.fromHex(native.toString());\n        }\n        if (native instanceof Buffer) {\n            return new _1.BytesValue(native);\n        }\n        if (typeof native === \"string\") {\n            return _1.BytesValue.fromUTF8(native);\n        }\n        if ((native.getTokenIdentifier)) {\n            return _1.BytesValue.fromUTF8(native.getTokenIdentifier());\n        }\n        errorContext.convertError(native, \"BytesValue\");\n    }\n    function convertNativeToBuffer(native, errorContext) {\n        if (native === undefined) {\n            errorContext.convertError(native, \"Buffer\");\n        }\n        if (native instanceof Buffer) {\n            return native;\n        }\n        if (typeof native === \"string\") {\n            return Buffer.from(native);\n        }\n        if ((native.getTokenIdentifier)) {\n            return Buffer.from(native.getTokenIdentifier());\n        }\n        errorContext.convertError(native, \"Buffer\");\n    }\n    function convertNativeToAddress(native, errorContext) {\n        switch (native.constructor) {\n            case __1.Address:\n            case Buffer:\n            case String:\n                return new __1.Address(native);\n            case contractWrapper_1.ContractWrapper:\n                return native.getAddress();\n            case smartContract_1.SmartContract:\n                return native.getAddress();\n            case testutils_1.TestWallet:\n                return native.address;\n            default:\n                errorContext.convertError(native, \"Address\");\n        }\n    }\n    NativeSerializer.convertNativeToAddress = convertNativeToAddress;\n    function convertNumericalType(number, type, errorContext) {\n        switch (type.constructor) {\n            case _1.U8Type:\n                return new _1.U8Value(number);\n            case _1.I8Type:\n                return new _1.I8Value(number);\n            case _1.U16Type:\n                return new _1.U16Value(number);\n            case _1.I16Type:\n                return new _1.I16Value(number);\n            case _1.U32Type:\n                return new _1.U32Value(number);\n            case _1.I32Type:\n                return new _1.I32Value(number);\n            case _1.U64Type:\n                return new _1.U64Value(number);\n            case _1.I64Type:\n                return new _1.I64Value(number);\n            case _1.BigUIntType:\n                return new _1.BigUIntValue(number);\n            case _1.BigIntType:\n                return new _1.BigIntValue(number);\n            default:\n                errorContext.unhandledType(\"convertNumericalType\", type);\n        }\n    }\n})(NativeSerializer = exports.NativeSerializer || (exports.NativeSerializer = {}));\n//# sourceMappingURL=nativeSerializer.js.map"]},"metadata":{},"sourceType":"script"}