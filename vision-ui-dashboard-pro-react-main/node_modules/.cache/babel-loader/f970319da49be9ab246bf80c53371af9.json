{"ast":null,"code":"import EventEmitter from \"events\";\nimport { TransportRaceCondition, TransportError, StatusCodes, getAltStatusMessage, TransportStatusError } from \"@ledgerhq/errors\";\nexport { TransportError, TransportStatusError, StatusCodes, getAltStatusMessage };\n/**\n */\n\n/**\n * Transport defines the generic interface to share between node/u2f impl\n * A **Descriptor** is a parametric type that is up to be determined for the implementation.\n * it can be for instance an ID, an file path, a URL,...\n */\n\nexport default class Transport {\n  constructor() {\n    var _this = this;\n\n    this.exchangeTimeout = 30000;\n    this.unresponsiveTimeout = 15000;\n    this.deviceModel = null;\n    this._events = new EventEmitter();\n\n    this.send = async function (cla, ins, p1, p2) {\n      let data = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Buffer.alloc(0);\n      let statusList = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [StatusCodes.OK];\n\n      if (data.length >= 256) {\n        throw new TransportError(\"data.length exceed 256 bytes limit. Got: \" + data.length, \"DataLengthTooBig\");\n      }\n\n      const response = await _this.exchange(Buffer.concat([Buffer.from([cla, ins, p1, p2]), Buffer.from([data.length]), data]));\n      const sw = response.readUInt16BE(response.length - 2);\n\n      if (!statusList.some(s => s === sw)) {\n        throw new TransportStatusError(sw);\n      }\n\n      return response;\n    };\n\n    this.exchangeBusyPromise = void 0;\n\n    this.exchangeAtomicImpl = async f => {\n      if (this.exchangeBusyPromise) {\n        throw new TransportRaceCondition(\"An action was already pending on the Ledger device. Please deny or reconnect.\");\n      }\n\n      let resolveBusy;\n      const busyPromise = new Promise(r => {\n        resolveBusy = r;\n      });\n      this.exchangeBusyPromise = busyPromise;\n      let unresponsiveReached = false;\n      const timeout = setTimeout(() => {\n        unresponsiveReached = true;\n        this.emit(\"unresponsive\");\n      }, this.unresponsiveTimeout);\n\n      try {\n        const res = await f();\n\n        if (unresponsiveReached) {\n          this.emit(\"responsive\");\n        }\n\n        return res;\n      } finally {\n        clearTimeout(timeout);\n        if (resolveBusy) resolveBusy();\n        this.exchangeBusyPromise = null;\n      }\n    };\n\n    this._appAPIlock = null;\n  }\n  /**\n   * low level api to communicate with the device\n   * This method is for implementations to implement but should not be directly called.\n   * Instead, the recommanded way is to use send() method\n   * @param apdu the data to send\n   * @return a Promise of response data\n   */\n\n\n  exchange(_apdu) {\n    throw new Error(\"exchange not implemented\");\n  }\n  /**\n   * set the \"scramble key\" for the next exchanges with the device.\n   * Each App can have a different scramble key and they internally will set it at instanciation.\n   * @param key the scramble key\n   */\n\n\n  setScrambleKey(_key) {}\n  /**\n   * close the exchange with the device.\n   * @return a Promise that ends when the transport is closed.\n   */\n\n\n  close() {\n    return Promise.resolve();\n  }\n  /**\n   * Listen to an event on an instance of transport.\n   * Transport implementation can have specific events. Here is the common events:\n   * * `\"disconnect\"` : triggered if Transport is disconnected\n   */\n\n\n  on(eventName, cb) {\n    this._events.on(eventName, cb);\n  }\n  /**\n   * Stop listening to an event on an instance of transport.\n   */\n\n\n  off(eventName, cb) {\n    this._events.removeListener(eventName, cb);\n  }\n\n  emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    this._events.emit(event, ...args);\n  }\n  /**\n   * Enable or not logs of the binary exchange\n   */\n\n\n  setDebugMode() {\n    console.warn(\"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\");\n  }\n  /**\n   * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n   */\n\n\n  setExchangeTimeout(exchangeTimeout) {\n    this.exchangeTimeout = exchangeTimeout;\n  }\n  /**\n   * Define the delay before emitting \"unresponsive\" on an exchange that does not respond\n   */\n\n\n  setExchangeUnresponsiveTimeout(unresponsiveTimeout) {\n    this.unresponsiveTimeout = unresponsiveTimeout;\n  }\n  /**\n   * wrapper on top of exchange to simplify work of the implementation.\n   * @param cla\n   * @param ins\n   * @param p1\n   * @param p2\n   * @param data\n   * @param statusList is a list of accepted status code (shorts). [0x9000] by default\n   * @return a Promise of response buffer\n   */\n\n  /**\n   * create() allows to open the first descriptor available or\n   * throw if there is none or if timeout is reached.\n   * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n   * @example\n  TransportFoo.create().then(transport => ...)\n   */\n\n\n  static create() {\n    let openTimeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3000;\n    let listenTimeout = arguments.length > 1 ? arguments[1] : undefined;\n    return new Promise((resolve, reject) => {\n      let found = false;\n      const sub = this.listen({\n        next: e => {\n          found = true;\n          if (sub) sub.unsubscribe();\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          this.open(e.descriptor, openTimeout).then(resolve, reject);\n        },\n        error: e => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          reject(e);\n        },\n        complete: () => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n\n          if (!found) {\n            reject(new TransportError(this.ErrorMessage_NoDeviceFound, \"NoDeviceFound\"));\n          }\n        }\n      });\n      const listenTimeoutId = listenTimeout ? setTimeout(() => {\n        sub.unsubscribe();\n        reject(new TransportError(this.ErrorMessage_ListenTimeout, \"ListenTimeout\"));\n      }, listenTimeout) : null;\n    });\n  }\n\n  decorateAppAPIMethods(self, methods, scrambleKey) {\n    for (let methodName of methods) {\n      self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);\n    }\n  }\n\n  decorateAppAPIMethod(methodName, f, ctx, scrambleKey) {\n    var _this2 = this;\n\n    return async function () {\n      const {\n        _appAPIlock\n      } = _this2;\n\n      if (_appAPIlock) {\n        return Promise.reject(new TransportError(\"Ledger Device is busy (lock \" + _appAPIlock + \")\", \"TransportLocked\"));\n      }\n\n      try {\n        _this2._appAPIlock = methodName;\n\n        _this2.setScrambleKey(scrambleKey);\n\n        for (var _len2 = arguments.length, args = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n\n        return await f.apply(ctx, args);\n      } finally {\n        _this2._appAPIlock = null;\n      }\n    };\n  }\n\n}\nTransport.isSupported = void 0;\nTransport.list = void 0;\nTransport.listen = void 0;\nTransport.open = void 0;\nTransport.ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\nTransport.ErrorMessage_NoDeviceFound = \"No Ledger device found\";","map":{"version":3,"sources":["../src/Transport.js"],"names":["Transport","isSupported","list","listen","open","exchange","setScrambleKey","close","Promise","on","off","emit","setDebugMode","console","setExchangeTimeout","setExchangeUnresponsiveTimeout","data","Buffer","statusList","StatusCodes","response","sw","s","create","openTimeout","found","sub","next","e","clearTimeout","error","reject","complete","listenTimeoutId","listenTimeout","setTimeout","busyPromise","r","resolveBusy","unresponsiveReached","timeout","res","f","decorateAppAPIMethods","self","decorateAppAPIMethod","_appAPIlock","ErrorMessage_ListenTimeout","ErrorMessage_NoDeviceFound"],"mappings":"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","sourcesContent":["//@flow\n\nimport EventEmitter from \"events\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport {\n  TransportRaceCondition,\n  TransportError,\n  StatusCodes,\n  getAltStatusMessage,\n  TransportStatusError,\n} from \"@ledgerhq/errors\";\n\nexport {\n  TransportError,\n  TransportStatusError,\n  StatusCodes,\n  getAltStatusMessage,\n};\n\n/**\n */\nexport type Subscription = { unsubscribe: () => void };\n\n/**\n */\nexport type Device = Object;\n\n/**\n * type: add or remove event\n * descriptor: a parameter that can be passed to open(descriptor)\n * deviceModel: device info on the model (is it a nano s, nano x, ...)\n * device: transport specific device info\n */\nexport type DescriptorEvent<Descriptor> = {\n  type: \"add\" | \"remove\",\n  descriptor: Descriptor,\n  deviceModel?: ?DeviceModel,\n  device?: Device,\n};\n/**\n */\nexport type Observer<Ev> = $ReadOnly<{\n  next: (event: Ev) => mixed,\n  error: (e: any) => mixed,\n  complete: () => mixed,\n}>;\n\n/**\n * Transport defines the generic interface to share between node/u2f impl\n * A **Descriptor** is a parametric type that is up to be determined for the implementation.\n * it can be for instance an ID, an file path, a URL,...\n */\nexport default class Transport<Descriptor> {\n  exchangeTimeout: number = 30000;\n  unresponsiveTimeout: number = 15000;\n  deviceModel: ?DeviceModel = null;\n\n  /**\n   * Statically check if a transport is supported on the user's platform/browser.\n   */\n  static +isSupported: () => Promise<boolean>;\n\n  /**\n   * List once all available descriptors. For a better granularity, checkout `listen()`.\n   * @return a promise of descriptors\n   * @example\n   * TransportFoo.list().then(descriptors => ...)\n   */\n  static +list: () => Promise<Array<Descriptor>>;\n\n  /**\n   * Listen all device events for a given Transport. The method takes an Obverver of DescriptorEvent and returns a Subscription (according to Observable paradigm https://github.com/tc39/proposal-observable )\n   * a DescriptorEvent is a `{ descriptor, type }` object. type can be `\"add\"` or `\"remove\"` and descriptor is a value you can pass to `open(descriptor)`.\n   * each listen() call will first emit all potential device already connected and then will emit events can come over times,\n   * for instance if you plug a USB device after listen() or a bluetooth device become discoverable.\n   * @param observer is an object with a next, error and complete function (compatible with observer pattern)\n   * @return a Subscription object on which you can `.unsubscribe()` to stop listening descriptors.\n   * @example\nconst sub = TransportFoo.listen({\n  next: e => {\n    if (e.type===\"add\") {\n      sub.unsubscribe();\n      const transport = await TransportFoo.open(e.descriptor);\n      ...\n    }\n  },\n  error: error => {},\n  complete: () => {}\n})\n   */\n  static +listen: (\n    observer: Observer<DescriptorEvent<Descriptor>>\n  ) => Subscription;\n\n  /**\n   * attempt to create a Transport instance with potentially a descriptor.\n   * @param descriptor: the descriptor to open the transport with.\n   * @param timeout: an optional timeout\n   * @return a Promise of Transport instance\n   * @example\nTransportFoo.open(descriptor).then(transport => ...)\n   */\n  static +open: (\n    descriptor: Descriptor,\n    timeout?: number\n  ) => Promise<Transport<Descriptor>>;\n\n  /**\n   * low level api to communicate with the device\n   * This method is for implementations to implement but should not be directly called.\n   * Instead, the recommanded way is to use send() method\n   * @param apdu the data to send\n   * @return a Promise of response data\n   */\n  exchange(_apdu: Buffer): Promise<Buffer> {\n    throw new Error(\"exchange not implemented\");\n  }\n\n  /**\n   * set the \"scramble key\" for the next exchanges with the device.\n   * Each App can have a different scramble key and they internally will set it at instanciation.\n   * @param key the scramble key\n   */\n  setScrambleKey(_key: string) {}\n\n  /**\n   * close the exchange with the device.\n   * @return a Promise that ends when the transport is closed.\n   */\n  close(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  _events = new EventEmitter();\n\n  /**\n   * Listen to an event on an instance of transport.\n   * Transport implementation can have specific events. Here is the common events:\n   * * `\"disconnect\"` : triggered if Transport is disconnected\n   */\n  on(eventName: string, cb: Function) {\n    this._events.on(eventName, cb);\n  }\n\n  /**\n   * Stop listening to an event on an instance of transport.\n   */\n  off(eventName: string, cb: Function) {\n    this._events.removeListener(eventName, cb);\n  }\n\n  emit(event: string, ...args: *) {\n    this._events.emit(event, ...args);\n  }\n\n  /**\n   * Enable or not logs of the binary exchange\n   */\n  setDebugMode() {\n    console.warn(\n      \"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\"\n    );\n  }\n\n  /**\n   * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n   */\n  setExchangeTimeout(exchangeTimeout: number) {\n    this.exchangeTimeout = exchangeTimeout;\n  }\n\n  /**\n   * Define the delay before emitting \"unresponsive\" on an exchange that does not respond\n   */\n  setExchangeUnresponsiveTimeout(unresponsiveTimeout: number) {\n    this.unresponsiveTimeout = unresponsiveTimeout;\n  }\n\n  /**\n   * wrapper on top of exchange to simplify work of the implementation.\n   * @param cla\n   * @param ins\n   * @param p1\n   * @param p2\n   * @param data\n   * @param statusList is a list of accepted status code (shorts). [0x9000] by default\n   * @return a Promise of response buffer\n   */\n  send = async (\n    cla: number,\n    ins: number,\n    p1: number,\n    p2: number,\n    data: Buffer = Buffer.alloc(0),\n    statusList: Array<number> = [StatusCodes.OK]\n  ): Promise<Buffer> => {\n    if (data.length >= 256) {\n      throw new TransportError(\n        \"data.length exceed 256 bytes limit. Got: \" + data.length,\n        \"DataLengthTooBig\"\n      );\n    }\n    const response = await this.exchange(\n      Buffer.concat([\n        Buffer.from([cla, ins, p1, p2]),\n        Buffer.from([data.length]),\n        data,\n      ])\n    );\n    const sw = response.readUInt16BE(response.length - 2);\n    if (!statusList.some((s) => s === sw)) {\n      throw new TransportStatusError(sw);\n    }\n    return response;\n  };\n\n  /**\n   * create() allows to open the first descriptor available or\n   * throw if there is none or if timeout is reached.\n   * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n   * @example\nTransportFoo.create().then(transport => ...)\n   */\n  static create(\n    openTimeout?: number = 3000,\n    listenTimeout?: number\n  ): Promise<Transport<Descriptor>> {\n    return new Promise((resolve, reject) => {\n      let found = false;\n      const sub = this.listen({\n        next: (e) => {\n          found = true;\n          if (sub) sub.unsubscribe();\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          this.open(e.descriptor, openTimeout).then(resolve, reject);\n        },\n        error: (e) => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          reject(e);\n        },\n        complete: () => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          if (!found) {\n            reject(\n              new TransportError(\n                this.ErrorMessage_NoDeviceFound,\n                \"NoDeviceFound\"\n              )\n            );\n          }\n        },\n      });\n      const listenTimeoutId = listenTimeout\n        ? setTimeout(() => {\n            sub.unsubscribe();\n            reject(\n              new TransportError(\n                this.ErrorMessage_ListenTimeout,\n                \"ListenTimeout\"\n              )\n            );\n          }, listenTimeout)\n        : null;\n    });\n  }\n\n  exchangeBusyPromise: ?Promise<void>;\n\n  // $FlowFixMe\n  exchangeAtomicImpl = async (f) => {\n    if (this.exchangeBusyPromise) {\n      throw new TransportRaceCondition(\n        \"An action was already pending on the Ledger device. Please deny or reconnect.\"\n      );\n    }\n    let resolveBusy;\n    const busyPromise = new Promise((r) => {\n      resolveBusy = r;\n    });\n    this.exchangeBusyPromise = busyPromise;\n    let unresponsiveReached = false;\n    const timeout = setTimeout(() => {\n      unresponsiveReached = true;\n      this.emit(\"unresponsive\");\n    }, this.unresponsiveTimeout);\n    try {\n      const res = await f();\n      if (unresponsiveReached) {\n        this.emit(\"responsive\");\n      }\n      return res;\n    } finally {\n      clearTimeout(timeout);\n      if (resolveBusy) resolveBusy();\n      this.exchangeBusyPromise = null;\n    }\n  };\n\n  decorateAppAPIMethods(\n    self: Object,\n    methods: Array<string>,\n    scrambleKey: string\n  ) {\n    for (let methodName of methods) {\n      self[methodName] = this.decorateAppAPIMethod(\n        methodName,\n        self[methodName],\n        self,\n        scrambleKey\n      );\n    }\n  }\n\n  _appAPIlock = null;\n  decorateAppAPIMethod<R, A: any[]>(\n    methodName: string,\n    f: (...args: A) => Promise<R>,\n    ctx: *,\n    scrambleKey: string\n  ): (...args: A) => Promise<R> {\n    return async (...args) => {\n      const { _appAPIlock } = this;\n      if (_appAPIlock) {\n        return Promise.reject(\n          new TransportError(\n            \"Ledger Device is busy (lock \" + _appAPIlock + \")\",\n            \"TransportLocked\"\n          )\n        );\n      }\n      try {\n        this._appAPIlock = methodName;\n        this.setScrambleKey(scrambleKey);\n        return await f.apply(ctx, args);\n      } finally {\n        this._appAPIlock = null;\n      }\n    };\n  }\n\n  static ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\n  static ErrorMessage_NoDeviceFound = \"No Ledger device found\";\n}\n"]},"metadata":{},"sourceType":"module"}